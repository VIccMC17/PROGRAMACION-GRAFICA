<!DOCTYPE HTML>
<html>
<head>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Arial, sans-serif;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      display: flex;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    }
    
    #menu {
      width: 250px;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 20px;
      overflow-y: auto;
      box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }
    
    #menu h2 {
      font-size: 24px;
      margin-bottom: 20px;
      color: #4CAF50;
      text-align: center;
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 10px;
    }
    
    .menu-item {
      background: rgba(76, 175, 80, 0.1);
      border: 2px solid #4CAF50;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .menu-item:hover {
      background: rgba(76, 175, 80, 0.3);
      transform: translateX(5px);
      box-shadow: 0 4px 8px rgba(76, 175, 80, 0.4);
    }
    
    .menu-item.active {
      background: rgba(76, 175, 80, 0.5);
      border-color: #81C784;
    }
    
    .menu-item-icon {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    
    .menu-item-text {
      flex: 1;
    }
    
    .menu-item-title {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 3px;
    }
    
    .menu-item-desc {
      font-size: 11px;
      color: #aaa;
    }

    /* Panel de opciones y colores */
    #options-panel {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #333;
      font-size: 13px;
    }

    #options-panel h3,
    #colors-panel h3 {
      font-size: 15px;
      margin-bottom: 8px;
      color: #FFEB3B;
    }

    .option-row {
      margin-bottom: 8px;
    }

    .option-row label {
      cursor: pointer;
      user-select: none;
    }

    #colors-panel {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px solid #333;
      font-size: 12px;
    }

    .color-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 6px;
    }

    .color-row label {
      flex: 1;
    }

    .color-row input[type="color"] {
      width: 38px;
      height: 22px;
      border: none;
      padding: 0;
      background: none;
      cursor: pointer;
    }
    
    #canvas-container {
      flex: 1;
      position: relative;
      display: flex;
      flex-direction: column;
    }
    
    #info-panel {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px 20px;
      text-align: center;
    }
    
    #info-panel h3 {
      font-size: 20px;
      color: #4CAF50;
      margin-bottom: 5px;
    }
    
    #info-panel p {
      font-size: 13px;
      color: #ccc;
    }
    
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    #controls-help {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-size: 12px;
      max-width: 220px;
    }
    
    #controls-help h4 {
      color: #4CAF50;
      margin-bottom: 8px;
    }
  </style>
  <title>Todos los Cubos 3D</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
  <div id="menu">
    <h2>üé≤ Cubos 3D</h2>
    <div class="menu-item active" data-cube="rubik3x3">
      <div class="menu-item-icon">3√ó3</div>
      <div class="menu-item-text">
        <div class="menu-item-title">Cubo Rubik 3x3</div>
        <div class="menu-item-desc">27 cubitos de colores</div>
      </div>
    </div>
    <div class="menu-item" data-cube="mirror">
      <div class="menu-item-icon">üíé</div>
      <div class="menu-item-text">
        <div class="menu-item-title">Cubo Mirror</div>
        <div class="menu-item-desc">Piezas doradas asim√©tricas</div>
      </div>
    </div>
    <div class="menu-item" data-cube="rubik5x5">
      <div class="menu-item-icon">5√ó5</div>
      <div class="menu-item-text">
        <div class="menu-item-title">Cubo Rubik 5x5</div>
        <div class="menu-item-desc">125 cubitos, m√°s complejo</div>
      </div>
    </div>
    <div class="menu-item" data-cube="pyraminx">
      <div class="menu-item-icon">üî∫</div>
      <div class="menu-item-text">
        <div class="menu-item-title">Pyraminx 3x3</div>
        <div class="menu-item-desc">Pieza triangular independiente</div>
      </div>
    </div>
    <div class="menu-item" data-cube="skewb">
      <div class="menu-item-icon">‚¨ú</div>
      <div class="menu-item-text">
        <div class="menu-item-title">Skewb cl√°sico</div>
        <div class="menu-item-desc">Centro romboidal y cortes diagonales</div>
      </div>
    </div>

    <!-- Panel de opciones -->
    <div id="options-panel">
      <h3>‚öôÔ∏è Opciones</h3>
      <div class="option-row">
        <label>
          <input type="checkbox" id="wireframeToggle">
          Modo malla (wireframe)
        </label>
      </div>
    </div>

    <!-- Panel de colores -->
    <div id="colors-panel">
      <h3>üé® Colores de las caras</h3>
      <p style="font-size:11px; margin-bottom:5px;">
        Afecta a: 3x3, 5x5 y Mirror.
      </p>
      <div id="color-pickers"></div>
    </div>
  </div>
  
  <div id="canvas-container">
    <div id="info-panel">
      <h3 id="cube-title">Cubo Rubik 3x3</h3>
      <p id="cube-description">El cl√°sico cubo de Rubik con 27 cubitos de colores.</p>
    </div>
    <canvas id="webglcanvas"></canvas>
    <div id="controls-help">
      <h4>‚å®Ô∏è Controles</h4>
      <p>üñ±Ô∏è Click + Arrastrar: Rotar puzzle<br>
      üì± Elige un puzzle del men√∫ para visualizarlo<br>
      üßµ ‚ÄúModo malla‚Äù muestra solo l√≠neas</p>
    </div>
  </div>

  <!-- Shaders compartidos -->
  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec4 aColores;
    out vec4 vColores;
    void main() {
      vColores = aColores;
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    in vec4 vColores;
    out vec4 color;
    void main() {
      color = vColores;
    }
  </script>

  <script>
    "use strict";

    /*******************************************************************/
    /* Utilidades de matrices (compartidas)                            */
    /*******************************************************************/
    function toRadians(grados) {
      return grados * Math.PI / 180;
    }

    function identidad(r) {
      r[0] = 1; r[4] = 0; r[8] = 0;  r[12] = 0;
      r[1] = 0; r[5] = 1; r[9] = 0;  r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function multiplica(c, a, b) {
      let r = new Array(16);
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          let s = 0;
          for (let k = 0; k < 4; k++)
            s += a[i + k * 4] * b[k + j * 4];
          r[i + j * 4] = s;
        }
      }
      for (let i = 0; i < 16; i++) c[i] = r[i];
    }

    function traslacion(matriz, tx, ty, tz) {
      let r = new Array(16);
      r[0] = 1; r[4] = 0; r[8] = 0;  r[12] = tx;
      r[1] = 0; r[5] = 1; r[9] = 0;  r[13] = ty;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function escalacion(matriz, sx, sy, sz) {
      let r = new Array(16);
      r[0] = sx; r[4] = 0;  r[8] = 0;  r[12] = 0;
      r[1] = 0;  r[5] = sy; r[9] = 0;  r[13] = 0;
      r[2] = 0;  r[6] = 0;  r[10] = sz; r[14] = 0;
      r[3] = 0;  r[7] = 0;  r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function rotacionX(matriz, theta) {
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] = 1; r[4] = 0;  r[8] = 0;  r[12] = 0;
      r[1] = 0; r[5] = c;  r[9] = -s; r[13] = 0;
      r[2] = 0; r[6] = s;  r[10] = c; r[14] = 0;
      r[3] = 0; r[7] = 0;  r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function rotacionY(matriz, theta) {
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] = c;  r[4] = 0; r[8] = s;  r[12] = 0;
      r[1] = 0;  r[5] = 1; r[9] = 0;  r[13] = 0;
      r[2] = -s; r[6] = 0; r[10] = c; r[14] = 0;
      r[3] = 0;  r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function ortho(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2/(der - izq); r[4] = 0;            r[8] = 0;                 r[12] = -(der + izq)/(der - izq);
      r[1] = 0;            r[5] = 2/(arr - abj); r[9] = 0;                 r[13] = -(arr + abj)/(arr - abj);
      r[2] = 0;            r[6] = 0;            r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
      r[3] = 0;            r[7] = 0;            r[11] = 0;                 r[15] = 1;
    }

    /*******************************************************************/
    /* Variables globales de WebGL y estado                            */
    /*******************************************************************/
    let gl, canvas, programaID;
    let uMatrizProyeccion, uMatrizVista, uMatrizModelo;
    let MatrizProyeccion = new Array(16);
    let MatrizVista      = new Array(16);
    let MatrizModelo     = new Array(16);

    let rotX = 30;
    let rotY = -30;
    let antX, antY;
    let boton_izq_presionado = false;

    let currentPuzzleKey = "rubik3x3";
    let wireframeEnabled = false;

    const puzzles = {};

    const hiddenColor = [0.1,0.1,0.1,1.0];

    // Colores globales por cara (para 3x3, 5x5 y Mirror)
    const globalCubeColorDefaults = {
      front: [1,1,1,1],     // frente: blanco
      back:  [1,1,0,1],     // atr√°s: amarillo
      left:  [1,0.5,0,1],   // izquierda: naranja
      right: [1,0,0,1],     // derecha: rojo
      up:    [0,1,0,1],     // arriba: verde
      down:  [0,0,1,1]      // abajo: azul
    };
    const globalCubeColors = JSON.parse(JSON.stringify(globalCubeColorDefaults));

    function faceColorHex(face){
      const c = globalCubeColors[face];
      const r = Math.round(c[0]*255).toString(16).padStart(2,"0");
      const g = Math.round(c[1]*255).toString(16).padStart(2,"0");
      const b = Math.round(c[2]*255).toString(16).padStart(2,"0");
      return "#" + r + g + b;
    }

    function hexToRgba(hex){
      let h = hex.replace("#","");
      if(h.length===3){
        h = h.split("").map(ch=>ch+ch).join("");
      }
      const r = parseInt(h.substring(0,2),16)/255;
      const g = parseInt(h.substring(2,4),16)/255;
      const b = parseInt(h.substring(4,6),16)/255;
      return [r,g,b,1];
    }

    /*******************************************************************/
    /* Manejo del rat√≥n                                                */
    /*******************************************************************/
    function mouseDown(event) {
      let rect = canvas.getBoundingClientRect();
      antX = event.clientX - rect.left;
      antY = event.clientY - rect.top;
      boton_izq_presionado = true;
      return false;
    }

    function mouseUp() {
      boton_izq_presionado = false;
    }

    function mouseMove(event) {
      if (!boton_izq_presionado) return false;
      let rect = canvas.getBoundingClientRect();
      let posx = event.clientX - rect.left;
      let posy = event.clientY - rect.top;
      let dx = posx - antX;
      let dy = posy - antY;
      rotX += dx * 0.5;
      rotY += dy * 0.5;
      antX = posx;
      antY = posy;
    }

    /*******************************************************************/
    /* Rubik 3x3                                                       */
    /*******************************************************************/
    (function(){
      // Mismas geometr√≠as que tu c√≥digo original (0.45)
      const r3Vertices = [
        -0.45, -0.45,  0.45,  0.45, -0.45,  0.45,  0.45,  0.45,  0.45, -0.45,  0.45,  0.45,
        -0.45,  0.45, -0.45,  0.45,  0.45, -0.45,  0.45, -0.45, -0.45, -0.45, -0.45, -0.45,
        -0.45, -0.45, -0.45, -0.45, -0.45,  0.45, -0.45,  0.45,  0.45, -0.45,  0.45, -0.45,
         0.45, -0.45,  0.45,  0.45, -0.45, -0.45,  0.45,  0.45, -0.45,  0.45,  0.45,  0.45,
        -0.45, -0.45, -0.45,  0.45, -0.45, -0.45,  0.45, -0.45,  0.45, -0.45, -0.45,  0.45,
        -0.45,  0.45,  0.45,  0.45,  0.45,  0.45,  0.45,  0.45, -0.45, -0.45,  0.45, -0.45
      ];
      const r3Indices = [
        0, 1, 2, 0, 2, 3,
        4, 5, 6, 4, 6, 7,
        8, 9, 10, 8, 10, 11,
        12, 13, 14, 12, 14, 15,
        16, 17, 18, 16, 18, 19,
        20, 21, 22, 20, 22, 23
      ];
      const faceVerts = [
        [0,1,2,3],    // front
        [4,5,6,7],    // back
        [8,9,10,11],  // left
        [12,13,14,15],// right
        [16,17,18,19],// down
        [20,21,22,23] // up
      ];
      const faceNames = ["front","back","left","right","down","up"];

      class Rubik3Cubito {
        constructor(x,y,z){
          this.x=x; this.y=y; this.z=z;
          this.solidVAO=null;
          this.solidColorBuffer=null;
          this.linesVAO=null;
          this.linesColorBuffer=null;
          this.lineVertexCount=0;
          this.initBuffers();
        }

        computeFaceColor(face){
          if(face==="front") return (this.z=== 1)? globalCubeColors.front : hiddenColor;
          if(face==="back")  return (this.z===-1)? globalCubeColors.back  : hiddenColor;
          if(face==="left")  return (this.x===-1)? globalCubeColors.left  : hiddenColor;
          if(face==="right") return (this.x=== 1)? globalCubeColors.right : hiddenColor;
          if(face==="up")    return (this.y=== 1)? globalCubeColors.up    : hiddenColor;
          if(face==="down")  return (this.y===-1)? globalCubeColors.down  : hiddenColor;
          return hiddenColor;
        }

        buildSolidColors(){
          const colors=[];
          for(let i=0;i<faceNames.length;i++){
            const col=this.computeFaceColor(faceNames[i]);
            for(let v=0;v<4;v++) colors.push(col[0],col[1],col[2],col[3]);
          }
          return new Float32Array(colors);
        }

        buildLineGeometryAndColors(){
          const verts=r3Vertices;
          const linePos=[], lineCol=[];
          for(let fi=0; fi<faceVerts.length; fi++){
            const idx = faceVerts[fi];
            const col = this.computeFaceColor(faceNames[fi]);
            const edges = [
              [idx[0],idx[1]],
              [idx[1],idx[2]],
              [idx[2],idx[3]],
              [idx[3],idx[0]]
            ];
            for(let e of edges){
              const i0=e[0]*3, i1=e[1]*3;
              linePos.push(
                verts[i0],verts[i0+1],verts[i0+2],
                verts[i1],verts[i1+1],verts[i1+2]
              );
              lineCol.push(
                col[0],col[1],col[2],col[3],
                col[0],col[1],col[2],col[3]
              );
            }
          }
          return {
            positions:new Float32Array(linePos),
            colors:new Float32Array(lineCol),
            count:linePos.length/3
          };
        }

        initBuffers(){
          // s√≥lido
          this.solidVAO=gl.createVertexArray();
          gl.bindVertexArray(this.solidVAO);

          const vboPos=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,vboPos);
          gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(r3Vertices),gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);

          this.solidColorBuffer=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.solidColorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER,this.buildSolidColors(),gl.DYNAMIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);

          const ebo=gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ebo);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(r3Indices),gl.STATIC_DRAW);
          gl.bindVertexArray(null);

          // l√≠neas
          const lineData=this.buildLineGeometryAndColors();
          this.lineVertexCount=lineData.count;

          this.linesVAO=gl.createVertexArray();
          gl.bindVertexArray(this.linesVAO);
          const lboPos=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,lboPos);
          gl.bufferData(gl.ARRAY_BUFFER,lineData.positions,gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);

          this.linesColorBuffer=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.linesColorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER,lineData.colors,gl.DYNAMIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          gl.bindVertexArray(null);
        }

        updateColors(){
          gl.bindBuffer(gl.ARRAY_BUFFER,this.solidColorBuffer);
          gl.bufferSubData(gl.ARRAY_BUFFER,0,this.buildSolidColors());
          gl.bindBuffer(gl.ARRAY_BUFFER,null);

          const lineData=this.buildLineGeometryAndColors();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.linesColorBuffer);
          gl.bufferSubData(gl.ARRAY_BUFFER,0,lineData.colors);
          gl.bindBuffer(gl.ARRAY_BUFFER,null);
          this.lineVertexCount=lineData.count;
        }
      }

      puzzles.rubik3x3 = {
        title: "Cubo Rubik 3x3",
        description: "Cubo cl√°sico con 27 cubitos independientes.",
        cubitos: [],
        initialized: false,
        init: function(){
          if (this.initialized) return;
          this.cubitos = [];
          for (let x=-1; x<=1; x++) {
            for (let y=-1; y<=1; y++) {
              for (let z=-1; z<=1; z++) {
                this.cubitos.push(new Rubik3Cubito(x,y,z));
              }
            }
          }
          this.initialized = true;
        },
        updateColors:function(){
          if(!this.initialized) return;
          this.cubitos.forEach(c=>c.updateColors());
        },
        draw: function(isWire){
          this.cubitos.forEach(c => {
            identidad(MatrizModelo);
            rotacionY(MatrizModelo, rotX);
            rotacionX(MatrizModelo, rotY);
            traslacion(MatrizModelo, c.x * 1.05, c.y * 1.05, c.z * 1.05);
            gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
            if(isWire){
              gl.bindVertexArray(c.linesVAO);
              gl.drawArrays(gl.LINES,0,c.lineVertexCount);
            }else{
              gl.bindVertexArray(c.solidVAO);
              gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            }
          });
          gl.bindVertexArray(null);
        }
      };
    })();

    /*******************************************************************/
    /* Rubik 5x5                                                       */
    /*******************************************************************/
    (function(){
      const tam = 0.38;
      const r5Vertices = [
        -tam, -tam,  tam,  tam, -tam,  tam,  tam,  tam,  tam, -tam,  tam,  tam,
        -tam,  tam, -tam,  tam,  tam, -tam,  tam, -tam, -tam, -tam, -tam, -tam,
        -tam, -tam, -tam, -tam, -tam,  tam, -tam,  tam,  tam, -tam,  tam, -tam,
         tam, -tam,  tam,  tam, -tam, -tam,  tam,  tam, -tam,  tam,  tam,  tam,
        -tam, -tam, -tam,  tam, -tam, -tam,  tam, -tam,  tam, -tam, -tam,  tam,
        -tam,  tam,  tam,  tam,  tam,  tam,  tam,  tam, -tam, -tam,  tam, -tam
      ];
      const r5Indices = [
        0, 1, 2, 0, 2, 3,
        4, 5, 6, 4, 6, 7,
        8, 9, 10, 8, 10, 11,
        12, 13, 14, 12, 14, 15,
        16, 17, 18, 16, 18, 19,
        20, 21, 22, 20, 22, 23
      ];
      const faceVerts = [
        [0,1,2,3],
        [4,5,6,7],
        [8,9,10,11],
        [12,13,14,15],
        [16,17,18,19],
        [20,21,22,23]
      ];
      const faceNames = ["front","back","left","right","down","up"];

      class Rubik5Cubito {
        constructor(x,y,z){
          this.x=x; this.y=y; this.z=z;
          this.solidVAO=null;
          this.solidColorBuffer=null;
          this.linesVAO=null;
          this.linesColorBuffer=null;
          this.lineVertexCount=0;
          this.initBuffers();
        }
        computeFaceColor(face){
          if(face==="front") return (this.z=== 2)? globalCubeColors.front : hiddenColor;
          if(face==="back")  return (this.z===-2)? globalCubeColors.back  : hiddenColor;
          if(face==="left")  return (this.x===-2)? globalCubeColors.left  : hiddenColor;
          if(face==="right") return (this.x=== 2)? globalCubeColors.right : hiddenColor;
          if(face==="up")    return (this.y=== 2)? globalCubeColors.up    : hiddenColor;
          if(face==="down")  return (this.y===-2)? globalCubeColors.down  : hiddenColor;
          return hiddenColor;
        }
        buildSolidColors(){
          const colors=[];
          for(let i=0;i<faceNames.length;i++){
            const col=this.computeFaceColor(faceNames[i]);
            for(let v=0;v<4;v++) colors.push(col[0],col[1],col[2],col[3]);
          }
          return new Float32Array(colors);
        }
        buildLineGeometryAndColors(){
          const verts=r5Vertices;
          const linePos=[], lineCol=[];
          for(let fi=0; fi<faceVerts.length; fi++){
            const idx=faceVerts[fi];
            const col=this.computeFaceColor(faceNames[fi]);
            const edges=[[idx[0],idx[1]],[idx[1],idx[2]],[idx[2],idx[3]],[idx[3],idx[0]]];
            for(let e of edges){
              const i0=e[0]*3,i1=e[1]*3;
              linePos.push(
                verts[i0],verts[i0+1],verts[i0+2],
                verts[i1],verts[i1+1],verts[i1+2]
              );
              lineCol.push(
                col[0],col[1],col[2],col[3],
                col[0],col[1],col[2],col[3]
              );
            }
          }
          return {
            positions:new Float32Array(linePos),
            colors:new Float32Array(lineCol),
            count:linePos.length/3
          };
        }
        initBuffers(){
          this.solidVAO=gl.createVertexArray();
          gl.bindVertexArray(this.solidVAO);
          const vboPos=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,vboPos);
          gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(r5Vertices),gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
          this.solidColorBuffer=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.solidColorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER,this.buildSolidColors(),gl.DYNAMIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          const ebo=gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ebo);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(r5Indices),gl.STATIC_DRAW);
          gl.bindVertexArray(null);

          const lineData=this.buildLineGeometryAndColors();
          this.lineVertexCount=lineData.count;
          this.linesVAO=gl.createVertexArray();
          gl.bindVertexArray(this.linesVAO);
          const lboPos=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,lboPos);
          gl.bufferData(gl.ARRAY_BUFFER,lineData.positions,gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
          this.linesColorBuffer=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.linesColorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER,lineData.colors,gl.DYNAMIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          gl.bindVertexArray(null);
        }
        updateColors(){
          gl.bindBuffer(gl.ARRAY_BUFFER,this.solidColorBuffer);
          gl.bufferSubData(gl.ARRAY_BUFFER,0,this.buildSolidColors());
          gl.bindBuffer(gl.ARRAY_BUFFER,null);
          const lineData=this.buildLineGeometryAndColors();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.linesColorBuffer);
          gl.bufferSubData(gl.ARRAY_BUFFER,0,lineData.colors);
          gl.bindBuffer(gl.ARRAY_BUFFER,null);
          this.lineVertexCount=lineData.count;
        }
      }

      puzzles.rubik5x5 = {
        title: "Cubo Rubik 5x5",
        description: "Cubo de orden 5x5x5 con 125 cubitos.",
        cubitos: [],
        initialized: false,
        init: function(){
          if (this.initialized) return;
          this.cubitos = [];
          for (let x=-2; x<=2; x++) {
            for (let y=-2; y<=2; y++) {
              for (let z=-2; z<=2; z++) {
                this.cubitos.push(new Rubik5Cubito(x,y,z));
              }
            }
          }
          this.initialized = true;
        },
        updateColors:function(){
          if(!this.initialized) return;
          this.cubitos.forEach(c=>c.updateColors());
        },
        draw: function(isWire){
          this.cubitos.forEach(c => {
            identidad(MatrizModelo);
            rotacionY(MatrizModelo, rotX);
            rotacionX(MatrizModelo, rotY);
            traslacion(MatrizModelo, c.x * 0.85, c.y * 0.85, c.z * 0.85);
            gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
            if(isWire){
              gl.bindVertexArray(c.linesVAO);
              gl.drawArrays(gl.LINES,0,c.lineVertexCount);
            }else{
              gl.bindVertexArray(c.solidVAO);
              gl.drawElements(gl.TRIANGLES,36,gl.UNSIGNED_SHORT,0);
            }
          });
          gl.bindVertexArray(null);
        }
      };
    })();

    /*******************************************************************/
    /* Mirror Cube                                                     */
    /*******************************************************************/
    (function(){
      const scales = [0.5, 1.0, 1.6];
      const gap = 0.1;
      const sizeMapX = { "-1": 0, "0": 2, "1": 1 }; 
      const sizeMapY = { "-1": 2, "0": 0, "1": 1 };
      const sizeMapZ = { "-1": 1, "0": 0, "1": 2 };

      function getScale(index,sizeMap){ return scales[sizeMap[index.toString()]]; }
      function getOffset(index, sizeMap) {
        let centerScale = scales[sizeMap["0"]];
        if (index === 0) return 0;
        let myScale = scales[sizeMap[index.toString()]];
        if (index === 1)  return centerScale + gap + myScale;
        if (index === -1) return -(centerScale + gap + myScale);
        return 0;
      }

      const mVertices = [
        // Frente
        -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  1,
        // Atr√°s
        -1,  1, -1,  1,  1, -1,  1, -1, -1, -1, -1, -1,
        // Izquierda
        -1, -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1,
        // Derecha
         1, -1,  1,  1, -1, -1,  1,  1, -1,  1,  1,  1,
        // Abajo
        -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1,
        // Arriba
        -1,  1,  1,  1,  1,  1,  1,  1, -1, -1,  1, -1
      ];
      const mIndices = [ 
        0,  1,  2,  0,  2,  3,
        4,  5,  6,  4,  6,  7,
        8,  9, 10,  8, 10, 11,
        12, 13, 14, 12, 14, 15,
        16, 17, 18, 16, 18, 19,
        20, 21, 22, 20, 22, 23
      ];
      const faceVerts = [
        [0,1,2,3],
        [4,5,6,7],
        [8,9,10,11],
        [12,13,14,15],
        [16,17,18,19],
        [20,21,22,23]
      ];
      const faceNames=["front","back","left","right","down","up"];

      class MirrorCubito {
        constructor(x,y,z){
          this.x=x; this.y=y; this.z=z;
          this.scale=[
            getScale(x,sizeMapX),
            getScale(y,sizeMapY),
            getScale(z,sizeMapZ)
          ];
          this.offset=[
            getOffset(x,sizeMapX),
            getOffset(y,sizeMapY),
            getOffset(z,sizeMapZ)
          ];
          this.solidVAO=null;
          this.solidColorBuffer=null;
          this.linesVAO=null;
          this.linesColorBuffer=null;
          this.lineVertexCount=0;
          this.initBuffers();
        }
        computeFaceColor(face){
          // igual que 3x3, pero adaptado a posici√≥n exterior
          if(face==="front") return (this.z=== 1)? globalCubeColors.front : hiddenColor;
          if(face==="back")  return (this.z===-1)? globalCubeColors.back  : hiddenColor;
          if(face==="left")  return (this.x===-1)? globalCubeColors.left  : hiddenColor;
          if(face==="right") return (this.x=== 1)? globalCubeColors.right : hiddenColor;
          if(face==="up")    return (this.y=== 1)? globalCubeColors.up    : hiddenColor;
          if(face==="down")  return (this.y===-1)? globalCubeColors.down  : hiddenColor;
          return hiddenColor;
        }
        buildSolidColors(){
          const colors=[];
          for(let i=0;i<faceNames.length;i++){
            const col=this.computeFaceColor(faceNames[i]);
            for(let v=0;v<4;v++) colors.push(col[0],col[1],col[2],col[3]);
          }
          return new Float32Array(colors);
        }
        buildLineGeometryAndColors(){
          const verts=mVertices;
          const linePos=[], lineCol=[];
          for(let fi=0;fi<faceVerts.length;fi++){
            const idx=faceVerts[fi];
            const col=this.computeFaceColor(faceNames[fi]);
            const edges=[[idx[0],idx[1]],[idx[1],idx[2]],[idx[2],idx[3]],[idx[3],idx[0]]];
            for(let e of edges){
              const i0=e[0]*3,i1=e[1]*3;
              linePos.push(
                verts[i0],verts[i0+1],verts[i0+2],
                verts[i1],verts[i1+1],verts[i1+2]
              );
              lineCol.push(
                col[0],col[1],col[2],col[3],
                col[0],col[1],col[2],col[3]
              );
            }
          }
          return {
            positions:new Float32Array(linePos),
            colors:new Float32Array(lineCol),
            count:linePos.length/3
          };
        }
        initBuffers(){
          this.solidVAO=gl.createVertexArray();
          gl.bindVertexArray(this.solidVAO);
          const vboPos=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,vboPos);
          gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(mVertices),gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
          this.solidColorBuffer=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.solidColorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER,this.buildSolidColors(),gl.DYNAMIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          const ebo=gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ebo);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(mIndices),gl.STATIC_DRAW);
          gl.bindVertexArray(null);

          const lineData=this.buildLineGeometryAndColors();
          this.lineVertexCount=lineData.count;
          this.linesVAO=gl.createVertexArray();
          gl.bindVertexArray(this.linesVAO);
          const lboPos=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,lboPos);
          gl.bufferData(gl.ARRAY_BUFFER,lineData.positions,gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
          this.linesColorBuffer=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.linesColorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER,lineData.colors,gl.DYNAMIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          gl.bindVertexArray(null);
        }
        updateColors(){
          gl.bindBuffer(gl.ARRAY_BUFFER,this.solidColorBuffer);
          gl.bufferSubData(gl.ARRAY_BUFFER,0,this.buildSolidColors());
          gl.bindBuffer(gl.ARRAY_BUFFER,null);
          const lineData=this.buildLineGeometryAndColors();
          gl.bindBuffer(gl.ARRAY_BUFFER,this.linesColorBuffer);
          gl.bufferSubData(gl.ARRAY_BUFFER,0,lineData.colors);
          gl.bindBuffer(gl.ARRAY_BUFFER,null);
          this.lineVertexCount=lineData.count;
        }
      }

      puzzles.mirror = {
        title: "Cubo Mirror",
        description: "27 bloques de distintos tama√±os. Colores de caras configurables.",
        initialized: false,
        bloques: [],
        init: function(){
          if (this.initialized) return;
          this.bloques=[];
          for (let x=-1; x<=1; x++) {
            for (let y=-1; y<=1; y++) {
              for (let z=-1; z<=1; z++) {
                this.bloques.push(new MirrorCubito(x,y,z));
              }
            }
          }
          this.initialized = true;
        },
        updateColors:function(){
          if(!this.initialized) return;
          this.bloques.forEach(b=>b.updateColors());
        },
        draw: function(isWire){
          this.bloques.forEach(b=>{
            identidad(MatrizModelo);
            rotacionY(MatrizModelo, rotX);
            rotacionX(MatrizModelo, rotY);
            traslacion(MatrizModelo, b.offset[0], b.offset[1], b.offset[2]);
            escalacion(MatrizModelo, b.scale[0], b.scale[1], b.scale[2]);
            gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
            if(isWire){
              gl.bindVertexArray(b.linesVAO);
              gl.drawArrays(gl.LINES,0,b.lineVertexCount);
            }else{
              gl.bindVertexArray(b.solidVAO);
              gl.drawElements(gl.TRIANGLES,36,gl.UNSIGNED_SHORT,0);
            }
          });
          gl.bindVertexArray(null);
        }
      };
    })();

    /*******************************************************************/
    /* Pyraminx 3x3                                                    */
    /*******************************************************************/
    (function(){
      let triVAO = null, lineVAO = null;
      let numTriVertices = 0;
      let numLineVertices = 0;

      function pushVec3(arr,v){ arr.push(v[0],v[1],v[2]); }
      function pushColor(arr,c){ arr.push(c[0],c[1],c[2],c[3]); }

      function addTriangle(vertices,colors,lineVerts,lineCols,p0,p1,p2,color){
        pushVec3(vertices,p0); pushColor(colors,color);
        pushVec3(vertices,p1); pushColor(colors,color);
        pushVec3(vertices,p2); pushColor(colors,color);
        let black=[0,0,0,1];
        pushVec3(lineVerts,p0); pushColor(lineCols,black);
        pushVec3(lineVerts,p1); pushColor(lineCols,black);
        pushVec3(lineVerts,p1); pushColor(lineCols,black);
        pushVec3(lineVerts,p2); pushColor(lineCols,black);
        pushVec3(lineVerts,p2); pushColor(lineCols,black);
        pushVec3(lineVerts,p0); pushColor(lineCols,black);
      }

      function subdivideFace(vertices,colors,lineVerts,lineCols,v0,v1,v2,color){
        let n = 3;
        let e1 = [v1[0]-v0[0], v1[1]-v0[1], v1[2]-v0[2]];
        let e2 = [v2[0]-v0[0], v2[1]-v0[1], v2[2]-v0[2]];
        function P(i,j){
          let fi = i/n, fj = j/n;
          return [
            v0[0] + fi*e1[0] + fj*e2[0],
            v0[1] + fi*e1[1] + fj*e2[1],
            v0[2] + fi*e1[2] + fj*e2[2]
          ];
        }
        for(let i=0;i<n;i++){
          for(let j=0;j<n-i;j++){
            let p0=P(i,j), p1=P(i+1,j), p2=P(i,j+1);
            addTriangle(vertices,colors,lineVerts,lineCols,p0,p1,p2,color);
          }
        }
        for(let i=0;i<n-1;i++){
          for(let j=0;j<n-1-i;j++){
            let p0=P(i+1,j), p1=P(i+1,j+1), p2=P(i,j+1);
            addTriangle(vertices,colors,lineVerts,lineCols,p0,p1,p2,color);
          }
        }
      }

      puzzles.pyraminx = {
        title: "Pyraminx 3x3",
        description: "Tetraedro subdividido en peque√±os tri√°ngulos con bordes negros.",
        initialized:false,
        init:function(){
          if (this.initialized) return;

          let A = [ 1,  1,  1];
          let B = [-1, -1,  1];
          let C = [-1,  1, -1];
          let D = [ 1, -1, -1];

          let faces = [
            {v0:A, v1:B, v2:C, color:[1,0,0,1]},
            {v0:A, v1:D, v2:B, color:[0,1,0,1]},
            {v0:A, v1:C, v2:D, color:[0,0,1,1]},
            {v0:B, v1:D, v2:C, color:[1,1,0,1]}
          ];

          let vertices = [];
          let colors   = [];
          let lineVerts= [];
          let lineCols = [];

          faces.forEach(f => subdivideFace(vertices,colors,lineVerts,lineCols,f.v0,f.v1,f.v2,f.color));

          numTriVertices  = vertices.length / 3;
          numLineVertices = lineVerts.length / 3;

          triVAO = gl.createVertexArray();
          gl.bindVertexArray(triVAO);
          let vboPos = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
          let vboCol = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vboCol);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          gl.bindVertexArray(null);

          lineVAO = gl.createVertexArray();
          gl.bindVertexArray(lineVAO);
          let lboPos = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, lboPos);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineVerts), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
          let lboCol = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, lboCol);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineCols), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          gl.bindVertexArray(null);

          this.initialized=true;
        },
        updateColors:function(){},
        draw:function(isWire){
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          escalacion(MatrizModelo,3,3,3);
          gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);

          if(isWire){
            gl.bindVertexArray(lineVAO);
            gl.lineWidth(2.0);
            gl.drawArrays(gl.LINES,0,numLineVertices);
          }else{
            gl.bindVertexArray(triVAO);
            gl.drawArrays(gl.TRIANGLES,0,numTriVertices);
            gl.bindVertexArray(null);

            gl.bindVertexArray(lineVAO);
            gl.lineWidth(2.0);
            gl.drawArrays(gl.LINES,0,numLineVertices);
          }
          gl.bindVertexArray(null);
        }
      };
    })();

    /*******************************************************************/
    /* Skewb cl√°sico                                                   */
    /*******************************************************************/
    (function(){
      let triVAO=null, lineVAO=null;
      let numTriVertices=0, numLineVertices=0;

      function mapFace(face, u, v){
        switch(face){
          case "front":  return [ u,  v,  1];
          case "back":   return [-u,  v, -1];
          case "right":  return [ 1,  v,  u];
          case "left":   return [-1,  v, -u];
          case "up":     return [ u,  1, -v];
          case "down":   return [ u, -1,  v];
        }
      }

      function pushVec3(arr,v){ arr.push(v[0],v[1],v[2]); }
      function pushColor(arr,c){ arr.push(c[0],c[1],c[2],c[3]); }

      function addTriangleFill(vertices,colors,face,p0,p1,p2,color){
        let P0 = mapFace(face,p0[0],p0[1]);
        let P1 = mapFace(face,p1[0],p1[1]);
        let P2 = mapFace(face,p2[0],p2[1]);
        pushVec3(vertices,P0); pushColor(colors,color);
        pushVec3(vertices,P1); pushColor(colors,color);
        pushVec3(vertices,P2); pushColor(colors,color);
      }

      function addEdge(lineVerts,lineCols,face,p0,p1){
        let P0 = mapFace(face,p0[0],p0[1]);
        let P1 = mapFace(face,p1[0],p1[1]);
        let black=[0,0,0,1];
        pushVec3(lineVerts,P0); pushColor(lineCols,black);
        pushVec3(lineVerts,P1); pushColor(lineCols,black);
      }

      function addSkewbFace(vertices,colors,lineVerts,lineCols,face,color){
        let TL = [-1,  1];
        let TR = [ 1,  1];
        let BR = [ 1, -1];
        let BL = [-1, -1];
        let MT = [ 0,  1];
        let MR = [ 1,  0];
        let MB = [ 0, -1];
        let ML = [-1,  0];

        // Esquinas
        addTriangleFill(vertices,colors,face, TL, MT, ML, color);
        addTriangleFill(vertices,colors,face, MT, TR, MR, color);
        addTriangleFill(vertices,colors,face, MR, BR, MB, color);
        addTriangleFill(vertices,colors,face, ML, MB, BL, color);

        // Bordes esquinas
        addEdge(lineVerts,lineCols,face, TL, MT);
        addEdge(lineVerts,lineCols,face, MT, ML);
        addEdge(lineVerts,lineCols,face, ML, TL);

        addEdge(lineVerts,lineCols,face, MT, TR);
        addEdge(lineVerts,lineCols,face, TR, MR);
        addEdge(lineVerts,lineCols,face, MR, MT);

        addEdge(lineVerts,lineCols,face, MR, BR);
        addEdge(lineVerts,lineCols,face, BR, MB);
        addEdge(lineVerts,lineCols,face, MB, MR);

        addEdge(lineVerts,lineCols,face, ML, MB);
        addEdge(lineVerts,lineCols,face, MB, BL);
        addEdge(lineVerts,lineCols,face, BL, ML);

        // Centro rombo MT-MR-MB-ML (2 tri√°ngulos, sin diagonal)
        addTriangleFill(vertices,colors,face, MT, MR, MB, color);
        addTriangleFill(vertices,colors,face, MT, MB, ML, color);

        addEdge(lineVerts,lineCols,face, MT, MR);
        addEdge(lineVerts,lineCols,face, MR, MB);
        addEdge(lineVerts,lineCols,face, MB, ML);
        addEdge(lineVerts,lineCols,face, ML, MT);
      }

      puzzles.skewb = {
        title:"Skewb cl√°sico",
        description:"Cada cara tiene 4 esquinas y 1 centro romboidal, con bordes negros.",
        initialized:false,
        init:function(){
          if (this.initialized) return;

          let verde   = [0,1,0,1];
          let azul    = [0,0,1,1];
          let rojo    = [1,0,0,1];
          let naranja = [1,0.5,0,1];
          let blanco  = [1,1,1,1];
          let amarillo= [1,1,0,1];

          let vertices=[], colors=[], lineVerts=[], lineCols=[];

          addSkewbFace(vertices,colors,lineVerts,lineCols,"front", verde);
          addSkewbFace(vertices,colors,lineVerts,lineCols,"back",  azul);
          addSkewbFace(vertices,colors,lineVerts,lineCols,"right", rojo);
          addSkewbFace(vertices,colors,lineVerts,lineCols,"left",  naranja);
          addSkewbFace(vertices,colors,lineVerts,lineCols,"up",    blanco);
          addSkewbFace(vertices,colors,lineVerts,lineCols,"down",  amarillo);

          numTriVertices  = vertices.length / 3;
          numLineVertices = lineVerts.length / 3;

          triVAO = gl.createVertexArray();
          gl.bindVertexArray(triVAO);
          let vboPos = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
          gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
          let vboCol = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vboCol);
          gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(colors),gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          gl.bindVertexArray(null);

          lineVAO = gl.createVertexArray();
          gl.bindVertexArray(lineVAO);
          let lboPos = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,lboPos);
          gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(lineVerts),gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
          let lboCol = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER,lboCol);
          gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(lineCols),gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1,4,gl.FLOAT,false,0,0);
          gl.bindVertexArray(null);

          this.initialized=true;
        },
        updateColors:function(){},
        draw:function(isWire){
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          escalacion(MatrizModelo,3,3,3);
          gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);

          if(isWire){
            gl.bindVertexArray(lineVAO);
            gl.lineWidth(2.0);
            gl.drawArrays(gl.LINES,0,numLineVertices);
          }else{
            gl.bindVertexArray(triVAO);
            gl.drawArrays(gl.TRIANGLES,0,numTriVertices);
            gl.bindVertexArray(null);

            gl.bindVertexArray(lineVAO);
            gl.lineWidth(2.0);
            gl.drawArrays(gl.LINES,0,numLineVertices);
          }
          gl.bindVertexArray(null);
        }
      };
    })();

    /*******************************************************************/
    /* Actualizar colores de todos los cubos                           */
    /*******************************************************************/
    function updateAllCubeColors(){
      if(puzzles.rubik3x3.initialized) puzzles.rubik3x3.updateColors();
      if(puzzles.rubik5x5.initialized) puzzles.rubik5x5.updateColors();
      if(puzzles.mirror.initialized)   puzzles.mirror.updateColors();
    }

    /*******************************************************************/
    /* Bucle de dibujo global                                          */
    /*******************************************************************/
    function render() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      puzzles[currentPuzzleKey].draw(wireframeEnabled);
      requestAnimationFrame(render);
    }

    /*******************************************************************/
    /* Inicializaci√≥n principal                                        */
    /*******************************************************************/
    function main() {
      canvas = document.getElementById("webglcanvas");
      const container = document.getElementById("canvas-container");
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight - 60;

      gl = canvas.getContext("webgl2");
      if (!gl) {
        document.write("WebGL 2.0 no est√° disponible en tu navegador");
        return;
      }

      canvas.addEventListener("mousedown", mouseDown, false);
      canvas.addEventListener("mouseup",   mouseUp,   false);
      canvas.addEventListener("mouseout",  mouseUp,   false);
      canvas.addEventListener("mousemove", mouseMove, false);

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      // Shaders
      let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
      gl.compileShader(shaderDeVertice);

      let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
      gl.compileShader(shaderDeFragmento);

      programaID = gl.createProgram();
      gl.attachShader(programaID, shaderDeVertice);
      gl.attachShader(programaID, shaderDeFragmento);
      gl.linkProgram(programaID);
      gl.useProgram(programaID);

      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista      = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo     = gl.getUniformLocation(programaID, "uMatrizModelo");

      let aspect = gl.canvas.width / gl.canvas.height;
      ortho(MatrizProyeccion, -8*aspect, 8*aspect, -8, 8, -20, 20);
      gl.uniformMatrix4fv(uMatrizProyeccion,false,MatrizProyeccion);

      identidad(MatrizVista);
      traslacion(MatrizVista,0,0,-10);
      gl.uniformMatrix4fv(uMatrizVista,false,MatrizVista);

      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.05,0.05,0.07,1.0);

      // Inicializar puzzle inicial
      puzzles[currentPuzzleKey].init();

      // Men√∫
      const menuItems = document.querySelectorAll('.menu-item');
      menuItems.forEach(item => {
        item.addEventListener('click', function(){
          menuItems.forEach(mi => mi.classList.remove('active'));
          this.classList.add('active');
          currentPuzzleKey = this.getAttribute('data-cube');
          puzzles[currentPuzzleKey].init();

          document.getElementById('cube-title').textContent = puzzles[currentPuzzleKey].title;
          document.getElementById('cube-description').textContent = puzzles[currentPuzzleKey].description;

          rotX = 30;
          rotY = -30;
        });
      });

      // Toggle de wireframe
      const wireToggle = document.getElementById("wireframeToggle");
      wireToggle.addEventListener("change", e=>{
        wireframeEnabled = e.target.checked;
      });

      // Color pickers
      const labels = {
        front:"Frente",
        back:"Atr√°s",
        left:"Izquierda",
        right:"Derecha",
        up:"Arriba",
        down:"Abajo"
      };
      const colorContainer = document.getElementById("color-pickers");
      ["front","back","left","right","up","down"].forEach(face=>{
        const row = document.createElement("div");
        row.className="color-row";
        const lab = document.createElement("label");
        lab.textContent = labels[face];
        const input = document.createElement("input");
        input.type="color";
        input.value=faceColorHex(face);
        input.dataset.face=face;
        input.addEventListener("input",e=>{
          const f=e.target.dataset.face;
          globalCubeColors[f]=hexToRgba(e.target.value);
          updateAllCubeColors();
        });
        row.appendChild(lab);
        row.appendChild(input);
        colorContainer.appendChild(row);
      });

      // Resize
      window.addEventListener('resize', function(){
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight - 60;
        gl.viewport(0,0,gl.canvas.width,gl.canvas.height);
        let aspect = gl.canvas.width / gl.canvas.height;
        ortho(MatrizProyeccion, -8*aspect, 8*aspect, -8, 8, -20, 20);
        gl.uniformMatrix4fv(uMatrizProyeccion,false,MatrizProyeccion);
      });

      render();
    }

    window.onload = main;
  </script>
</body>
</html>
