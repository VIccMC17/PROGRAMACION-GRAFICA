<!DOCTYPE HTML>
<html>
<head>
    <style type="text/css">
        #canvas-holder {
            float: left;
            margin-right: 10px;
        }
    </style>
    <title>Casa tipo Minecraft con iluminación Phong</title>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
</head>
<body>
<div id="content">
    <div id="canvas-holder">
        <canvas id="webglcanvas" style="border: none;" width="700" height="700"></canvas>

        <!-- Texturas -->
        <img src="bloques2.jpeg"  id="imagenTexturaB1"     hidden /> <!-- Tierra -->
        <img src="bloques.png"    id="imagenTexturaB2"     hidden /> <!-- Piedra/Madera/otros -->
        <img src="window.png"     id="imagenTexturaWindow" hidden /> <!-- Ventana -->
    </div>
</div>

<!-- Vertex Shader con Phong (como IluminacionCuboColor, pero con textura) -->
<script id="vs" type="vertex">
#version 300 es
precision mediump float;

uniform mat4 uMatrizProyeccion;
uniform mat4 uMatrizVista;
uniform mat4 uMatrizModelo;

layout(location = 0) in vec3 aVertices;
layout(location = 1) in vec2 aCoordenadasDeTextura;
layout(location = 2) in vec3 aNormales;

out vec2 vCoordenadasDeTextura;
out vec3 vNormales;
out vec3 vVertices;

void main() {
    vCoordenadasDeTextura = aCoordenadasDeTextura;

    // Normales y vértices a coordenadas de cámara (igual que el ejemplo)
    vNormales = mat3(uMatrizVista) * mat3(uMatrizModelo) * normalize(aNormales);
    vec4 vertices = uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
    vVertices = vertices.xyz / vertices.w;

    gl_Position = uMatrizProyeccion * vertices;
}
</script>

<!-- Fragment Shader Phong + textura -->
<script id="fs" type="fragment">
#version 300 es
precision highp float;

uniform sampler2D uUnidadDeTextura;

uniform vec3 uPosicionVista;
uniform vec3 uPosicionLuz;
uniform vec3 u_Ia;
uniform vec3 u_Id;
uniform vec3 u_Is;
uniform vec3 u_ka;
uniform vec3 u_kd;
uniform vec3 u_ks;
uniform float u_brillo;

in vec2 vCoordenadasDeTextura;
in vec3 vNormales;
in vec3 vVertices;

out vec4 color;

void main() {
    // Color base de la textura
    vec3 texColor = texture(uUnidadDeTextura, vCoordenadasDeTextura).rgb;

    // Vectores en coordenadas de cámara
    vec3 N = normalize(vNormales);
    vec3 L = normalize(uPosicionLuz - vVertices);
    vec3 V = normalize(uPosicionVista - vVertices);
    vec3 H = normalize(L + V);

    float NL = max(0.0, dot(N, L));
    float NH = max(0.0, dot(N, H));

    // Material modulado por la textura
    vec3 ka = u_ka * texColor;
    vec3 kd = u_kd * texColor;
    vec3 ks = u_ks; // brillo blanco/gris

    vec3 luzAmbiente  = ka * u_Ia;
    vec3 luzDifusa    = kd * u_Id * NL;
    vec3 luzEspecular = ks * u_Is * pow(NH, u_brillo);

    vec3 rgb = luzAmbiente + luzDifusa + luzEspecular;
    color = vec4(rgb, 1.0);
}
</script>

<script>
"use strict";

/* ==================== PATRÓN DE LA CASA (desde tu imagen) ==================== */
const patron = [
    "TTTTTTTTTT",
    "TTTTTTTTTT",
    "TTPMVVMPTT",
    "TTMMMVFMTT",
    "TTVMMMMVTT",
    "TTVMMMMVTT",
    "TTMMMMMMTT",
    "TTPMVVMPTT",
    "TTTTTTTTTT",
    "TTTTTTTTTT"
];
const FILAS    = patron.length;
const COLUMNAS = patron[0].length;

/* WebGL globales */
let gl, programaID, canvas;

/* Uniforms */
let uMatrizProyeccion, uMatrizVista, uMatrizModelo, uUnidadDeTextura;
let uPosicionVista, uPosicionLuz, u_Ia, u_Id, u_Is, u_ka, u_kd, u_ks, u_brillo;

/* Bloques */
let bloqueTierra, bloquePiedra, bloqueMadera, bloqueVentana, mesaDeCrafteo, horno;

/* Texturas */
let texTierra, texPiedra, texMadera, texVentana, texMesaDeCrafteo, texHorno;

/* Ratón / cámara */
let boton_izq_presionado = false;
let antX = 0, antY = 0;
let rotX = 5;    // inclinación inicial
let rotY = 5;    // giro inicial
let camDist = 12; // zoom inicial

/* Matrices */
let MatrizProyeccion = new Array(16);
let MatrizVista      = new Array(16);
let MatrizModelo     = new Array(16);

/* ==================== Utilidades de matrices ==================== */
function toRadians(g){ return g * Math.PI / 180; }

function identidad(r){
    r[0]=1;r[4]=0;r[8]=0;r[12]=0;
    r[1]=0;r[5]=1;r[9]=0;r[13]=0;
    r[2]=0;r[6]=0;r[10]=1;r[14]=0;
    r[3]=0;r[7]=0;r[11]=0;r[15]=1;
}

function multiplica(c,a,b){
    let r=new Array(16);
    for(let i=0;i<4;i++){
        for(let j=0;j<4;j++){
            let s=0;
            for(let k=0;k<4;k++) s+=a[i+4*k]*b[k+4*j];
            r[i+4*j]=s;
        }
    }
    for(let i=0;i<16;i++) c[i]=r[i];
}

function traslacion(m,tx,ty,tz){
    let r=new Array(16);
    r[0]=1;r[4]=0;r[8]=0;r[12]=tx;
    r[1]=0;r[5]=1;r[9]=0;r[13]=ty;
    r[2]=0;r[6]=0;r[10]=1;r[14]=tz;
    r[3]=0;r[7]=0;r[11]=0;r[15]=1;
    multiplica(m,m,r);
}

function rotacionX(m,theta){
    let r=new Array(16),c=Math.cos(toRadians(theta)),s=Math.sin(toRadians(theta));
    r[0]=1;r[4]=0;r[8]=0;r[12]=0;
    r[1]=0;r[5]=c;r[9]=-s;r[13]=0;
    r[2]=0;r[6]=s;r[10]=c;r[14]=0;
    r[3]=0;r[7]=0;r[11]=0;r[15]=1;
    multiplica(m,m,r);
}

function rotacionY(m,theta){
    let r=new Array(16),c=Math.cos(toRadians(theta)),s=Math.sin(toRadians(theta));
    r[0]=c;r[4]=0;r[8]=s;r[12]=0;
    r[1]=0;r[5]=1;r[9]=0;r[13]=0;
    r[2]=-s;r[6]=0;r[10]=c;r[14]=0;
    r[3]=0;r[7]=0;r[11]=0;r[15]=1;
    multiplica(m,m,r);
}

function frustum(r, izq, der, abj, arr, cerca, lejos) {
    r[0]=2*cerca/(der-izq); r[4]=0;                 r[8]=(der+izq)/(der-izq);  r[12]=0;
    r[1]=0;                 r[5]=2*cerca/(arr-abj); r[9]=(arr+abj)/(arr-abj);  r[13]=0;
    r[2]=0;                 r[6]=0;                 r[10]=-(lejos+cerca)/(lejos-cerca); r[14]=-2*lejos*cerca/(lejos-cerca);
    r[3]=0;                 r[7]=0;                 r[11]=-1;                r[15]=0;
}

/* ==================== Bloques (con normales) ==================== */
class BloqueBase{
    constructor(gl, coord_textura){
        // Cubo 1x1x1 centrado en el origen
        let vertices = [
            // Frente
            -0.5,-0.5, 0.5,  0.5,-0.5, 0.5,  0.5, 0.5, 0.5,  -0.5, 0.5, 0.5,
            // Atrás
            -0.5, 0.5,-0.5,  0.5, 0.5,-0.5,  0.5,-0.5,-0.5,  -0.5,-0.5,-0.5,
            // Izquierda
            -0.5,-0.5,-0.5, -0.5,-0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5,-0.5,
            // Derecha
             0.5,-0.5, 0.5,  0.5,-0.5,-0.5,  0.5, 0.5,-0.5,  0.5, 0.5, 0.5,
            // Abajo
            -0.5,-0.5,-0.5,  0.5,-0.5,-0.5,  0.5,-0.5, 0.5, -0.5,-0.5, 0.5,
            // Arriba
            -0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  0.5, 0.5,-0.5, -0.5, 0.5,-0.5
        ];

        let normales = [
            // Frente
             0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1,
            // Atrás
             0, 0,-1,  0, 0,-1,  0, 0,-1,  0, 0,-1,
            // Izquierda
            -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
            // Derecha
             1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0,
            // Abajo
             0,-1, 0,  0,-1, 0,  0,-1, 0,  0,-1, 0,
            // Arriba
             0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0
        ];

        let indices = [
             0,  1,  2,  0,  2,  3,
             4,  5,  6,  4,  6,  7,
             8,  9, 10,  8, 10, 11,
            12, 13, 14, 12, 14, 15,
            16, 17, 18, 16, 18, 19,
            20, 21, 22, 20, 22, 23
        ];

        const final_coords = coord_textura || new Array(48).fill(0);

        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);

        let vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);

        let tbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(final_coords), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1,2,gl.FLOAT,false,0,0);

        let nbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normales), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2,3,gl.FLOAT,false,0,0);

        let ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER,null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);
    }

    muestra(gl, tex){
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uUnidadDeTextura,0);
        gl.bindTexture(gl.TEXTURE_2D,tex);
        gl.bindVertexArray(this.vao);
        gl.drawElements(gl.TRIANGLES,36,gl.UNSIGNED_SHORT,0);
        gl.bindVertexArray(null);
    }
}

class BloqueTierra extends BloqueBase{
    constructor(gl){
        let uv = [
            1/8,10/12, 2/8,10/12, 2/8,11/12, 1/8,11/12,
            1/8,10/12, 2/8,10/12, 2/8,11/12, 1/8,11/12,
            1/8,10/12, 2/8,10/12, 2/8,11/12, 1/8,11/12,
            1/8,10/12, 2/8,10/12, 2/8,11/12, 1/8,11/12,
            1/8,10/12, 2/8,10/12, 2/8,11/12, 1/8,11/12,
            0/8,10/12, 1/8,10/12, 1/8,11/12, 0/8,11/12
        ];
        super(gl,uv);
    }
    muestratierra(gl,tex){ super.muestra(gl,tex); }
}

class BloquePiedra extends BloqueBase{
    constructor(gl){
        let uv=[];
        for(let i=0;i<6;i++) uv.push(6/16,9/10,7/16,9/10,7/16,10/10,6/16,10/10);
        super(gl,uv);
    }
    muestrapiedra(gl,tex){ super.muestra(gl,tex); }
}

class BloqueMadera extends BloqueBase{
    constructor(gl){
        let uv=[];
        for(let i=0;i<6;i++) uv.push(4/16,9/10,5/16,9/10,5/16,10/10,4/16,10/10);
        super(gl,uv);
    }
    muestramadera(gl,tex){ super.muestra(gl,tex); }
}

class BloqueVentana extends BloqueBase{
    constructor(gl){
        let uv=[];
        for(let i=0;i<6;i++) uv.push(0,0,1,0,1,1,0,1);
        super(gl,uv);
    }
    muestraventana(gl,tex){ super.muestra(gl,tex); }
}

class MesaDeCrafteo extends BloqueBase{
    constructor(gl){
        let uv = [
            11/16,6/10,12/16,6/10,12/16,7/10,11/16,7/10,
            11/16,6/10,12/16,6/10,12/16,7/10,11/16,7/10,
            12/16,6/10,13/16,6/10,13/16,7/10,12/16,7/10,
            12/16,6/10,13/16,6/10,13/16,7/10,12/16,7/10,
            11/16,7/10,12/16,7/10,12/16,8/10,11/16,8/10,
            11/16,7/10,12/16,7/10,12/16,8/10,11/16,8/10
        ];
        super(gl,uv);
    }
    muestramesadecrafteo(gl,tex){ super.muestra(gl,tex); }
}

class Horno extends BloqueBase{
    constructor(gl){
        let uv = [
            12/16,7/10,13/16,7/10,13/16,8/10,12/16,8/10,
            13/16,7/10,14/16,7/10,14/16,8/10,13/16,8/10,
            13/16,7/10,14/16,7/10,14/16,8/10,13/16,8/10,
            13/16,7/10,14/16,7/10,14/16,8/10,13/16,8/10,
            14/16,6/10,15/16,6/10,15/16,7/10,14/16,7/10,
            14/16,6/10,15/16,6/10,15/16,7/10,14/16,7/10
        ];
        super(gl,uv);
    }
    muestrahorno(gl,tex){ super.muestra(gl,tex); }
}

/* ==================== Texturas ==================== */
function leeLaTextura(gl,idImg,tex){
    gl.bindTexture(gl.TEXTURE_2D,tex);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true);
    let img=document.getElementById(idImg);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
    gl.bindTexture(gl.TEXTURE_2D,null);
}

/* ==================== Casa helpers ==================== */
function esPilar(x,z){ return patron[z][x]==='P'; }

function esParedMadera(x,z){
    if(patron[z][x] !== 'M') return false;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(let d of dirs){
        let nx=x+d[0], nz=z+d[1];
        if(nx<0||nx>=COLUMNAS||nz<0||nz>=FILAS) continue;
        if(patron[nz][nx]==='T') return true;
    }
    return false;
}

/* ==================== Ratón / cámara ==================== */
function mouseDown(ev){
    let r=canvas.getBoundingClientRect();
    antX=ev.clientX-r.left;
    antY=ev.clientY-r.top;
    boton_izq_presionado=true;
}
function mouseUp(){ boton_izq_presionado=false; }
function mouseMove(ev){
    if(!boton_izq_presionado) return;
    let r=canvas.getBoundingClientRect();
    let x=ev.clientX-r.left, y=ev.clientY-r.top;
    let dx=x-antX, dy=y-antY;
    rotY+=dx*0.3;
    rotX+=dy*0.3;
    antX=x; antY=y;
}
function ruedaMouse(ev){
    ev.preventDefault();
    camDist += ev.deltaY*0.05;
    if(camDist<8) camDist=8;
    if(camDist>35) camDist=35;
}

/* ==================== Dibujo ==================== */
function dibuja(){
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

    // Cámara tipo orbita (vista)
    identidad(MatrizVista);
    traslacion(MatrizVista, -5, -3, -camDist); // centro aprox (5,0,5)
    rotacionY(MatrizVista, rotY);
    rotacionX(MatrizVista, rotX);
    gl.uniformMatrix4fv(uMatrizVista,false,MatrizVista);

    // Modelo base identidad
    identidad(MatrizModelo);
    let base = MatrizModelo.slice();

    /* Suelo */
    for(let z=0;z<FILAS;z++){
        for(let x=0;x<COLUMNAS;x++){
            for(let i=0;i<16;i++) MatrizModelo[i]=base[i];
            traslacion(MatrizModelo,x,0,z);
            gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
            let ch=patron[z][x];
            if(ch==='T') bloqueTierra.muestratierra(gl,texTierra);
            else         bloqueMadera.muestramadera(gl,texMadera);
        }
    }

    /* Pilares */
    for(let z=0;z<FILAS;z++){
        for(let x=0;x<COLUMNAS;x++){
            if(!esPilar(x,z)) continue;
            for(let y=1;y<=3;y++){
                for(let i=0;i<16;i++) MatrizModelo[i]=base[i];
                traslacion(MatrizModelo,x,y,z);
                gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
                bloquePiedra.muestrapiedra(gl,texPiedra);
            }
        }
    }

    /* Paredes + ventanas */
    for(let z=0;z<FILAS;z++){
        for(let x=0;x<COLUMNAS;x++){
            let ch=patron[z][x];

            if(ch==='V'){
                for(let y=1;y<=2;y++){
                    for(let i=0;i<16;i++) MatrizModelo[i]=base[i];
                    traslacion(MatrizModelo,x,y,z);
                    gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
                    bloqueVentana.muestraventana(gl,texVentana);
                }
            } else if(esParedMadera(x,z)){
                for(let y=1;y<=2;y++){
                    for(let i=0;i<16;i++) MatrizModelo[i]=base[i];
                    traslacion(MatrizModelo,x,y,z);
                    gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
                    bloqueMadera.muestramadera(gl,texMadera);
                }
            }
        }
    }

    /* Horno + mesa (bloque F) */
    let xF=-1,zF=-1;
    for(let z=0;z<FILAS;z++)
        for(let x=0;x<COLUMNAS;x++)
            if(patron[z][x]==='F'){ xF=x; zF=z; }

    if(xF>=0){
        // Horno
        for(let i=0;i<16;i++) MatrizModelo[i]=base[i];
        traslacion(MatrizModelo,xF,1,zF);
        gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
        horno.muestrahorno(gl,texHorno);

        // Mesa justo detrás
        let xC=xF, zC=zF+1;
        if(zC<FILAS && patron[zC][xC]==='M' && !esParedMadera(xC,zC)){
            for(let i=0;i<16;i++) MatrizModelo[i]=base[i];
            traslacion(MatrizModelo,xC,1,zC);
            gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
            mesaDeCrafteo.muestramesadecrafteo(gl,texMesaDeCrafteo);
        }
    }

    requestAnimationFrame(dibuja);
}

/* ==================== Shaders ==================== */
function compilaEnlazaLosShaders(){
    let vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs,document.getElementById("vs").text.trim());
    gl.compileShader(vs);
    if(!gl.getShaderParameter(vs,gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(vs));

    let fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs,document.getElementById("fs").text.trim());
    gl.compileShader(fs);
    if(!gl.getShaderParameter(fs,gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(fs));

    programaID = gl.createProgram();
    gl.attachShader(programaID,vs);
    gl.attachShader(programaID,fs);
    gl.linkProgram(programaID);
    if(!gl.getProgramParameter(programaID,gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(programaID));

    gl.useProgram(programaID);
}

/* ==================== main ==================== */
function main(){
    canvas = document.getElementById("webglcanvas");
    gl = canvas.getContext("webgl2");
    if(!gl){
        document.write("WebGL 2.0 no disponible");
        return;
    }

    gl.viewport(0,0,gl.canvas.width,gl.canvas.height);
    compilaEnlazaLosShaders();

    // Bloques
    bloqueTierra  = new BloqueTierra(gl);
    bloquePiedra  = new BloquePiedra(gl);
    bloqueMadera  = new BloqueMadera(gl);
    bloqueVentana = new BloqueVentana(gl);
    mesaDeCrafteo = new MesaDeCrafteo(gl);
    horno         = new Horno(gl);

    // Texturas
    texTierra        = gl.createTexture();
    texPiedra        = gl.createTexture();
    texMadera        = gl.createTexture();
    texVentana       = gl.createTexture();
    texMesaDeCrafteo = gl.createTexture();
    texHorno         = gl.createTexture();

    leeLaTextura(gl,"imagenTexturaB1",    texTierra);
    leeLaTextura(gl,"imagenTexturaB2",    texPiedra);
    leeLaTextura(gl,"imagenTexturaB2",    texMadera);
    leeLaTextura(gl,"imagenTexturaWindow",texVentana);
    leeLaTextura(gl,"imagenTexturaB2",    texMesaDeCrafteo);
    leeLaTextura(gl,"imagenTexturaB2",    texHorno);

    // Uniforms
    uMatrizProyeccion = gl.getUniformLocation(programaID,"uMatrizProyeccion");
    uMatrizVista      = gl.getUniformLocation(programaID,"uMatrizVista");
    uMatrizModelo     = gl.getUniformLocation(programaID,"uMatrizModelo");
    uUnidadDeTextura  = gl.getUniformLocation(programaID,"uUnidadDeTextura");

    uPosicionVista = gl.getUniformLocation(programaID,"uPosicionVista");
    uPosicionLuz   = gl.getUniformLocation(programaID,"uPosicionLuz");
    u_Ia = gl.getUniformLocation(programaID,"u_Ia");
    u_Id = gl.getUniformLocation(programaID,"u_Id");
    u_Is = gl.getUniformLocation(programaID,"u_Is");
    u_ka = gl.getUniformLocation(programaID,"u_ka");
    u_kd = gl.getUniformLocation(programaID,"u_kd");
    u_ks = gl.getUniformLocation(programaID,"u_ks");
    u_brillo = gl.getUniformLocation(programaID,"u_brillo");

    // Proyección
    frustum(MatrizProyeccion,-5,5,-5,5,2,60);
    gl.uniformMatrix4fv(uMatrizProyeccion,false,MatrizProyeccion);

    // Parámetros de iluminación tipo Phong
    gl.uniform3f(uPosicionVista,0.0,0.0,0.0);      // cámara en el origen de la vista
    gl.uniform3f(uPosicionLuz,5.0,6.0,3.0);        // luz arriba/delante
    gl.uniform3f(u_Ia,0.3,0.3,0.3);                // luz ambiente
    gl.uniform3f(u_Id,1.0,1.0,1.0);                // luz difusa blanca
    gl.uniform3f(u_Is,0.8,0.8,0.8);                // luz especular
    gl.uniform3f(u_ka,1.0,1.0,1.0);                // material base
    gl.uniform3f(u_kd,1.0,1.0,1.0);
    gl.uniform3f(u_ks,0.4,0.4,0.4);
    gl.uniform1f(u_brillo,64.0);                   // brillo especular

    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.4,0.7,1.0,1.0);

    // Ventanas con alpha
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);

    canvas.addEventListener("mousedown",mouseDown,false);
    canvas.addEventListener("mouseup",mouseUp,false);
    canvas.addEventListener("mousemove",mouseMove,false);
    canvas.addEventListener("wheel",ruedaMouse,{passive:false});

    dibuja();
}

window.onload = main;
</script>
</body>
</html>
