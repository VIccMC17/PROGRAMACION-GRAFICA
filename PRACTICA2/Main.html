
<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title>Triángulos — mover + escalar + rotar (P, V, M)</title>
  <style>
    body { display:grid; place-items:center; height:100vh; margin:0; background:#000; color:#ddd; font:14px system-ui, Arial; }
    #hint { opacity:.9; user-select:none; margin-top:.5rem; text-align:center; }
  </style>
</head>
<body>
  <canvas id="webglcanvas" width="500" height="500" style="border:none"></canvas>
  <div id="hint">
    Click = seleccionar y arrastrar (crece mientras presionas).<br/>
    Rueda o Q/E = rotar triángulo seleccionado (Shift = más rápido). R = reset. ESC = deseleccionar.
  </div>

  <!-- VS con Proyección, Vista y Modelo -->
  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    layout (location = 0) in vec2 aVertices;
    void main() {
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision mediump float;
    uniform vec4 uColor;
    out vec4 color;
    void main(){ color = uColor; }
  </script>

  <script>
    /* ===== Matrices ===== */
    function identidad(r){ r[0]=1;r[4]=0;r[8]=0; r[12]=0; r[1]=0;r[5]=1;r[9]=0; r[13]=0; r[2]=0;r[6]=0;r[10]=1;r[14]=0; r[3]=0;r[7]=0;r[11]=0;r[15]=1; }
    function multiplica(c,a,b){
      const r=new Array(16);
      for(let i=0;i<4;i++){ for(let j=0;j<4;j++){
        let s=0; for(let k=0;k<4;k++) s+=a[i+k*4]*b[k+j*4];
        r[i+j*4]=s; } }
      for(let i=0;i<16;i++) c[i]=r[i];
    }
    function traslacion(m,tx,ty,tz){ const r=[1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1]; multiplica(m,m,r); }
    function escala(m,sx,sy,sz){ const r=[sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1]; multiplica(m,m,r); }
    function rotZ(m,ang){
      const c=Math.cos(ang), s=Math.sin(ang);
      const r=[ c, s,0,0, -s, c,0,0, 0,0,1,0, 0,0,0,1 ];
      multiplica(m,m,r);
    }
    // Ortográfica opcional (no usada por defecto)
    function ortho(out,l,r,b,t,n,f){
      identidad(out);
      out[0]=2/(r-l); out[5]=2/(t-b); out[10]=-2/(f-n);
      out[12]=-(r+l)/(r-l); out[13]=-(t+b)/(t-b); out[14]=-(f+n)/(f-n);
    }

    /* ===== Utiles ===== */
    function centrarVertices(verts){
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for(let i=0;i<verts.length;i+=2){ const x=verts[i], y=verts[i+1];
        if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; }
      const cx=(minX+maxX)/2, cy=(minY+maxY)/2, out=new Array(verts.length);
      for(let i=0;i<verts.length;i+=2){ out[i]=verts[i]-cx; out[i+1]=verts[i+1]-cy; }
      return out;
    }
    function _sign(p1,p2,p3){ return (p1.x-p3.x)*(p2.y-p3.y) - (p2.x-p3.x)*(p1.y-p3.y); }
    function puntoEnTri(p,a,b,c){ const b1=_sign(p,a,b)<0, b2=_sign(p,b,c)<0, b3=_sign(p,c,a)<0; return (b1===b2)&&(b2===b3); }
    function pixelToNDC(canvas,x,y){ return { x:(x/canvas.width)*2-1, y:1-(y/canvas.height)*2 }; }
    function deltaPixelToNDC(canvas,dx,dy){ return { x:2*dx/canvas.width, y:-2*dy/canvas.height }; }

    function main(){
      const canvas=document.getElementById("webglcanvas");
      const gl=canvas.getContext("webgl2");
      if(!gl){ alert("WebGL2 no disponible"); return; }
      gl.viewport(0,0,gl.canvas.width,gl.canvas.height);

      // Compilar y linkear
      function comp(tipo,src){ const s=gl.createShader(tipo); gl.shaderSource(s,src.trim()); gl.compileShader(s);
        if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s; }
      const prog=gl.createProgram();
      gl.attachShader(prog, comp(gl.VERTEX_SHADER, document.getElementById("vs").text));
      gl.attachShader(prog, comp(gl.FRAGMENT_SHADER, document.getElementById("fs").text));
      gl.linkProgram(prog); if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw gl.getProgramInfoLog(prog);
      gl.useProgram(prog);

      // === Geometría (igual que antes) ===
      let vertices=[
        // CONTORNO
        0.333,-0.013, 0.341,-0.013, 0.394,-0.038, 0.396,-0.187, 0.38,-0.219,
        0.397,-0.651, 0.399,-0.657, 0.492,-0.69, 0.497,-0.692, 0.509,-0.706,
        0.545,-0.755, 0.552,-0.833, 0.533,-0.9, 0.528,-0.942, 0.528,-0.945,
        0.579,-1.036, 0.622,-1.12, 0.627,-1.216, 0.588,-1.296, 0.504,-1.353,
        0.393,-1.373, 0.261,-1.375, 0.157,-1.34, 0.152,-1.334, 0.097,-1.27,
        0.074,-1.191, 0.086,-1.111, 0.166,-0.951, 0.136,-0.862, 0.13,-0.789,
        0.161,-0.721, 0.22,-0.679, 0.283,-0.664, 0.29,-0.659, 0.297,-0.212,
        0.287,-0.195, 0.289,-0.043,
        // TRIÁNGULOS / STRIPS (interiores)
        0.311,-0.042, 0.337,-0.026, 0.382,-0.047, 0.383,-0.080,
        0.303,-0.055, 0.371,-0.090, 0.301,-0.116,
        0.385,-0.096, 0.320,-0.124, 0.384,-0.135,
        0.300,-0.132, 0.367,-0.141, 0.299,-0.180,
        0.304,-0.193, 0.316,-0.209, 0.385,-0.184, 0.381,-0.146,
        0.380,-0.197, 0.368,-0.219, 0.328,-0.220, 0.369,-0.253,
        0.310,-0.226, 0.310,-0.300, 0.365,-0.266,
        0.369,-0.276, 0.312,-0.312, 0.374,-0.379,
        0.308,-0.329, 0.309,-0.391, 0.368,-0.390,
        0.309,-0.405, 0.371,-0.402, 0.309,-0.486,
        0.375,-0-420, 0.311,-0.511, 0.380,-0.561,
        0.306,-0.530, 0.374,-0.576, 0.306,-0.651,
        0.316,-0.661, 0.378,-0.591, 0.383,-0.657,
        0.168,-0.737, 0.146,-0.784, 0.214,-0.765,
        0.173,-0.725, 0.223,-0.753, 0.217,-0.698,
        0.232,-0.698, 0.236,-0.759, 0.284,-0.738,
        0.239,-0.688, 0.290,-0.676, 0.290,-0.726,
        0.304,-0.730, 0.304,-0.684, 0.368,-0.722,
        0.320,-0.673, 0.384,-0.670, 0.386,-0.715,
        0.397,-0.675, 0.398,-0.716, 0.471,-0.695,
        0.403,-0.730, 0.480,-0.707, 0.451,-0.776,
        0.461,-0.781, 0.495,-0.710, 0.530,-0.756,
        0.156,-0.795, 0.227,-0.775, 0.244,-0.841,
        0.242,-0.784, 0.285,-0.819, 0.261,-0.843,
        0.248,-0.769, 0.288,-0.752, 0.289,-0.802,
        0.302,-0.755, 0.302,-0.805, 0.341,-0.797,
        0.311,-0.746, 0.377,-0.734, 0.351,-0.783,
        0.384,-0.747, 0.359,-0.795, 0.390,-0.801,
        0.396,-0.743, 0.403,-0.798, 0.441,-0.785,
        0.146,-0.806, 0.150,-0.854, 0.233,-0.854,
        0.154,-0.870, 0.239,-0.867, 0.177,-0.938,
        0.192,-0.939, 0.250,-0.875, 0.252,-0.917,
        0.261,-0.867, 0.264,-0.914, 0.328,-0.892,
        0.330,-0.880, 0.269,-0.857, 0.295,-0.828,
        0.306,-0.820, 0.343,-0.809, 0.342,-0.871,
        0.358,-0.807, 0.355,-0.869, 0.384,-0.811,
        0.395,-0.822, 0.363,-0.881, 0.421,-0.854,
        0.406,-0.813, 0.446,-0.799, 0.435,-0.844,
        0.458,-0.801, 0.447,-0.848, 0.529,-0.840,
        0.467,-0.791, 0.536,-0.770, 0.540,-0.829,
        0.368,-0.893, 0.431,-0.866, 0.431,-0.911,
        0.441,-0.873, 0.443,-0.917, 0.497,-0.931,
        0.455,-0.859, 0.536,-0.850, 0.525,-0.887,
        0.520,-0.899, 0.461,-0.877, 0.518,-0.933,
        0.200,-0.950, 0.257,-0.928, 0.274,-0.957,
        0.271,-0.925, 0.288,-0.951, 0.322,-0.910,
        0.336,-0.913, 0.297,-0.961, 0.334,-0.978,
        0.351,-0.910, 0.347,-0.976, 0.390,-0.965,
        0.361,-0.904, 0.400,-0.958, 0.425,-0.923,
        0.432,-0.930, 0.405,-0.972, 0.467,-0.994,
        0.443,-0.928, 0.475,-0.988, 0.511,-0.949,
        0.158,-0.999, 0.179,-0.965, 0.235,-1.016,
        0.191,-0.961, 0.257,-1.014, 0.273,-0.971,
        0.286,-0.973, 0.268,-1.016, 0.319,-0.989,
        0.109,-1.097, 0.150,-1.019, 0.194,-1.067,
        0.160,-1.012, 0.211,-1.062, 0.245,-1.031,
        0.219,-1.074, 0.255,-1.042, 0.284,-1.132,
        0.271,-1.044, 0.301,-1.137, 0.363,-1.081,
        0.272,-1.029, 0.330,-0.996, 0.362,-1.066,
        0.344,-0.993, 0.390,-0.981, 0.376,-1.061,
        0.403,-0.984, 0.383,-1.068, 0.454,-1.003,
        0.463,-1.015, 0.394,-1.077, 0.466,-1.112,
        0.478,-1.011, 0.482,-1.109, 0.560,-1.048,
        0.484,-1.000, 0.520,-0.960, 0.564,-1.033,
        0.101,-1.122, 0.090,-1.175, 0.157,-1.149,
        0.113,-1.109, 0.172,-1.138, 0.194,-1.082,
        0.187,-1.141, 0.211,-1.085, 0.277,-1.141,
        0.320,-1.139, 0.378,-1.087, 0.451,-1.121,
        0.489,-1.118, 0.573,-1.055, 0.607,-1.122,
        0.089,-1.190, 0.104,-1.245, 0.158,-1.163,
        0.116,-1.255, 0.173,-1.166, 0.204,-1.225,
        0.189,-1.156, 0.215,-1.216, 0.283,-1.153,
        0.225,-1.228, 0.289,-1.164, 0.301,-1.267,
        0.305,-1.163, 0.316,-1.269, 0.398,-1.240,
        0.315,-1.154, 0.457,-1.132, 0.412,-1.231,
        0.474,-1.137, 0.549,-1.191, 0.429,-1.233,
        0.489,-1.130, 0.564,-1.182, 0.604,-1.136,
        0.117,-1.268, 0.157,-1.320, 0.201,-1.240,
        0.211,-1.247, 0.172,-1.330, 0.252,-1.355,
        0.223,-1.242, 0.300,-1.282, 0.265,-1.353,
        0.276,-1.361, 0.313,-1.294, 0.366,-1.358,
        0.333,-1.295, 0.382,-1.358, 0.463,-1.346,
        0.335,-1.278, 0.410,-1.252, 0.474,-1.335,
        0.429,-1.254, 0.497,-1.338, 0.555,-1.300,
        0.432,-1.245, 0.565,-1.286, 0.559,-1.207,
        0.582,-1.276, 0.575,-1.212, 0.607,-1.228,
        0.577,-1.188, 0.614,-1.148, 0.614,-1.214
      ];
      vertices = centrarVertices(vertices);

      const indices=[
        // contorno
        0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,
        // interiores (orden original)
        37,38,40,39, 41,42,43, 44,45,46, 47,48,49, 51,50,52,53, 54,55,56,57,
        58,59,60, 61,62,63, 64,65,66, 67,68,69, 70,71,72, 73,74,75, 76,77,78,
        79,80,81, 82,83,84, 85,86,87, 88,89,90, 91,92,93, 94,95,96, 97,98,99,
        100,101,102, 103,104,105, 106,107,108, 109,110,111, 112,113,114, 115,116,117, 118,119,120, 121,122,123,
        124,125,126, 127,128,129, 130,131,132, 133,134,135, 136,137,138, 139,140,141, 142,143,144, 145,146,147,
        148,149,150, 151,152,153, 154,155,156, 157,158,159, 160,161,162, 163,164,165, 166,167,168, 169,170,171,
        172,173,174, 175,176,177, 178,179,180, 181,182,183, 184,185,186, 187,188,189, 190,191,192, 193,194,195,
        196,197,198, 199,200,201, 202,203,204, 205,206,207, 208,209,210, 211,212,213, 214,215,216, 217,218,219,
        220,221,222, 223,224,225, 226,227,228, 229,230,231, 232,233,234, 235,236,237, 238,239,240, 241,242,243,
        244,245,246, 247,248,249, 250,251,252, 253,254,255, 256,257,258, 259,260,261, 262,263,264, 265,266,267,
        268,269,270, 271,272,273, 274,275,276, 277,278,279, 280,281,282, 283,284,285, 286,287,288, 289,290,291,
        292,293,294, 295,296,297, 298,299,300
      ];

      // Buffers / VAO
      const vao=gl.createVertexArray(); gl.bindVertexArray(vao);
      const vbo=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
      const ebo=gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      gl.bindVertexArray(null); gl.bindBuffer(gl.ARRAY_BUFFER,null); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);

      // Uniforms
      const uColor=gl.getUniformLocation(prog,"uColor");
      const uMatrizModelo=gl.getUniformLocation(prog,"uMatrizModelo");
      const uMatrizProyeccion=gl.getUniformLocation(prog,"uMatrizProyeccion");
      const uMatrizVista=gl.getUniformLocation(prog,"uMatrizVista");

      const MP=new Float32Array(16); const MV=new Float32Array(16); const MM=new Float32Array(16);
      identidad(MP); identidad(MV);
      gl.useProgram(prog);
      gl.uniformMatrix4fv(uMatrizProyeccion,false,MP);
      gl.uniformMatrix4fv(uMatrizVista,false,MV);

      // ===== Arreglo de triángulos =====
      const startInteriores=37;
      const baseChunks=[{mode:'strip',count:4},{mode:'tri',count:3},{mode:'tri',count:3},{mode:'tri',count:3},{mode:'strip',count:4},{mode:'strip',count:4}];
      let usados=baseChunks.reduce((s,c)=>s+c.count,0);
      const restantes=indices.length - startInteriores - usados;
      const nTriRest=Math.max(0, Math.floor(restantes/3));
      for(let i=0;i<nTriRest;i++) baseChunks.push({mode:'tri',count:3});
      const triangles=[]; let ptr=startInteriores;
      for(const ch of baseChunks){
        if(ch.mode==='tri'){ triangles.push({ptr, i0:indices[ptr], i1:indices[ptr+1], i2:indices[ptr+2]}); ptr+=3; }
        else{ if(ch.count>=3) triangles.push({ptr:ptr, i0:indices[ptr], i1:indices[ptr+1], i2:indices[ptr+2]});
              if(ch.count>=4) triangles.push({ptr:ptr+1, i0:indices[ptr+1], i1:indices[ptr+2], i2:indices[ptr+3]}); ptr+=ch.count; }
      }

      // ===== Estado por triángulo =====
      const tX=new Float32Array(triangles.length);
      const tY=new Float32Array(triangles.length);
      const s =new Float32Array(triangles.length); s.fill(1);
      const ang=new Float32Array(triangles.length); // radianes

      // Centroide p/ pivot
      const cX=new Float32Array(triangles.length);
      const cY=new Float32Array(triangles.length);
      for(let i=0;i<triangles.length;i++){
        const tri=triangles[i];
        const ax=vertices[2*tri.i0], ay=vertices[2*tri.i0+1];
        const bx=vertices[2*tri.i1], by=vertices[2*tri.i1+1];
        const cx_=vertices[2*tri.i2], cy_=vertices[2*tri.i2+1];
        cX[i]=(ax+bx+cx_)/3; cY[i]=(ay+by+cy_)/3;
      }

      // Colores
      const triColors=new Float32Array(triangles.length*4);
      const esc = [
        [138/255,97/255,  7/255,1],[138/255,97/255,  7/255,1],
        [ 65/255,93/255,105/255,1],[132/255,36/255, 24/255,1],
        [ 39/255, 8/255,  6/255,1],[ 31/255,26/255, 48/255,1],[ 31/255,26/255, 48/255,1],
        [ 54/255,18/255, 28/255,1],[ 54/255,18/255, 28/255,1],
        [133/255,93/255, 21/255,1],[  7/255,18/255, 40/255,1],
        [ 59/255,96/255,114/255,1],[ 63/255,23/255, 26/255,1],
        [  1.0  ,75/255, 53/255,1],[ 23/255,75/255, 75/255,1],
        [ 41/255, 1.0  ,  1.0  ,1],
      ];
      function hsl2rgb(h,s,l){
        function f(n){ const k=(n+h*6)%6, a=s*Math.min(l,1-l);
          return l - a*Math.max(-1, Math.min(k-3, Math.min(9-k,1))); }
        return [f(0),f(8/6),f(4/6)];
      }
      for(let i=0;i<triangles.length;i++){
        let rgba; if(i<esc.length) rgba=esc[i]; else { const h=(i-esc.length)/Math.max(1,(triangles.length-esc.length)); const rgb=hsl2rgb(h,0.6,0.6); rgba=[rgb[0],rgb[1],rgb[2],1]; }
        triColors[i*4+0]=rgba[0]; triColors[i*4+1]=rgba[1]; triColors[i*4+2]=rgba[2]; triColors[i*4+3]=rgba[3];
      }

      // ===== Picking con rotación (usa inversa de M sin escala) =====
      function worldToLocal(i, p){ // aplica M^-1 a p (sin escala)
        // M = T(tx,ty) · T(cx,cy) · R(ang) · T(-cx,-cy)
        // M^-1 = T(cx,cy) · R(-ang) · T(-cx,-cy) · T(-tx,-ty)
        let x=p.x - tX[i], y=p.y - tY[i];
        x -= cX[i]; y -= cY[i];
        const c=Math.cos(-ang[i]), s=Math.sin(-ang[i]);
        const xr = x*c + y*s;
        const yr = -x*s + y*c;
        return { x: xr + cX[i], y: yr + cY[i] };
      }
      function getTriUnderCursor(px,py){
        const p = pixelToNDC(canvas,px,py);
        for(let i=triangles.length-1;i>=0;i--){
          const tri=triangles[i];
          const pl = worldToLocal(i,p);
          const a={x:vertices[2*tri.i0], y:vertices[2*tri.i0+1]};
          const b={x:vertices[2*tri.i1], y:vertices[2*tri.i1+1]};
          const c={x:vertices[2*tri.i2], y:vertices[2*tri.i2+1]};
          if(puntoEnTri(pl,a,b,c)) return i;
        }
        return -1;
      }

      // ===== Interacción =====
      let active=-1, dragging=false, lastX=0,lastY=0;
      const SCALE_WHEN_HELD = 1.25;
      const DEG = Math.PI/180;

      canvas.addEventListener('mousedown', (e)=>{
        active = getTriUnderCursor(e.offsetX, e.offsetY);
        if(active!==-1){
          s[active]=SCALE_WHEN_HELD;
          dragging=true; lastX=e.offsetX; lastY=e.offsetY;
          draw();
        }
      });

      canvas.addEventListener('mousemove',(e)=>{
        if(!dragging||active===-1) return;
        const d=deltaPixelToNDC(canvas, e.offsetX-lastX, e.offsetY-lastY);
        lastX=e.offsetX; lastY=e.offsetY;
        tX[active]+=d.x; tY[active]+=d.y; draw();
      });

      function release(){
        if(active!==-1){ s[active]=1; } // vuelve a tamaño original, pero mantiene selección
        dragging=false; draw();
      }
      canvas.addEventListener('mouseup',   release);
      canvas.addEventListener('mouseleave',release);

      // Rueda del mouse: rotar seleccionado o el que esté bajo el cursor
      canvas.addEventListener('wheel',(e)=>{
        e.preventDefault();
        let target = (active!==-1)? active : getTriUnderCursor(e.offsetX, e.offsetY);
        if(target===-1) return;
        const step = (e.deltaY<0 ? -1 : 1) * 5 * DEG; // 5° por "tick"
        ang[target] += step;
        draw();
      }, {passive:false});

      // Teclado: Q/E rotación; Shift = 15°. R = reset; ESC deseleccionar
      window.addEventListener('keydown',(ev)=>{
        if(active===-1 && ev.key!=='Escape') return;
        const fast = ev.shiftKey ? 15 : 5;
        if(ev.key.toLowerCase()==='q'){ ang[active] += fast*DEG; draw(); }
        if(ev.key.toLowerCase()==='e'){ ang[active] -= fast*DEG; draw(); }
        if(ev.key.toLowerCase()==='r'){ tX[active]=0; tY[active]=0; ang[active]=0; s[active]=1; draw(); }
        if(ev.key==='Escape'){ active=-1; draw(); }
      });

      // ===== Dibujo =====
      function draw(){
        gl.clearColor(35/255,9/255,0/255,1); gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(prog); gl.bindVertexArray(vao);

        // Contorno (fijo)
        identidad(MM);
        gl.uniformMatrix4fv(uMatrizModelo,false,MM);
        gl.uniform4f(uColor,1,1,1,1);
        gl.drawElements(gl.LINE_LOOP, 37, gl.UNSIGNED_SHORT, 0);

        // Triángulos
        for(let i=0;i<triangles.length;i++){
          const tri=triangles[i], off=tri.ptr*2; // bytes
          identidad(MM);
          traslacion(MM, tX[i], tY[i], 0);
          traslacion(MM, cX[i], cY[i], 0);
          rotZ(MM, ang[i]);            // ← rotación por triángulo
          escala(MM, s[i], s[i], 1);   // ← escala al presionar
          traslacion(MM, -cX[i], -cY[i], 0);

          gl.uniformMatrix4fv(uMatrizModelo,false,MM);
          gl.uniform4f(uColor, triColors[i*4+0], triColors[i*4+1], triColors[i*4+2], triColors[i*4+3]);
          gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_SHORT, off);

          if(i===active){
            gl.uniform4f(uColor,1,1,1,1);
            gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, off);
          }
        }
        gl.bindVertexArray(null);
      }

      draw();
    }
    window.onload=main;
  </script>
</body>
</html>
