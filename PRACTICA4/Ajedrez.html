<!DOCTYPE HTML>
<html>
<head>
    <title>Textura 2D en WebGL 2.0</title>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    
    <style>
        body {
            /* 1. Fondo que cubre toda la pantalla */
            background-image: url("fondo.jpg");
            background-size: cover;
            background-attachment: fixed; /* Asegura que la imagen no se mueva al hacer scroll */
            background-position: center center;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #webglcanvas {
            /* 2. Hace el canvas HTML transparente */
            background-color: transparent; 
            border: none;
        }
        h2, #turno_display {
            color: white; /* Mejora la visibilidad del texto sobre fondos oscuros */
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <h2>Textura 2D en WebGL 2.0</h2>
    <div id="turno_display">Turno: Blanco</div>
    <canvas id="webglcanvas" width="500" height="500"></canvas>
    
    <img src="imagen2.png" id="imagenTablero" hidden />
    
    <img src="reyblanco.png" id="imagenTReyblanco" hidden />
    <img src="reynegro.png" id="imagenTReyNegro" hidden />
    <img src="reinablanca.png" id="imagenTReinaBlanca" hidden />
    <img src="reinanegra.png" id="imagenTReinaNegro" hidden />
    <img src="alfilblanco.png" id="imagenTAlfilBlanco" hidden />
    <img src="alfilnegro.png" id="imagenTAlfilNegro" hidden />
    <img src="caballoblanco.png" id="imagenTCaballoBlanco" hidden />
    <img src="caballonegro.png" id="imagenTCaballoNegro" hidden />
    <img src="torreblanco.png" id="imagenTTorreBlanco" hidden />
    <img src="torrenegra.png" id="imagenTTorreNegro" hidden />
    <img src="peonblanco.png" id="imagenTPeonBlanco" hidden />
    <img src="peonnegro.png" id="imagenTPeonNegro" hidden />
    
    <script id="vs" type="vertex">
        #version 300 es
        precision mediump float;
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec2 aVertices;
        layout(location = 1) in vec2 aCoordenadasDeTextura;
        out vec2 vCoordenadasDeTextura;
        void main() {
            vCoordenadasDeTextura = aCoordenadasDeTextura;  
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D uUnidadDeTextura;
        in vec2 vCoordenadasDeTextura;
        out vec4 color;
        void main() {
            color = texture(uUnidadDeTextura, vCoordenadasDeTextura); 
        }
    </script>
    
    <script>
        'use strict';

        /* Variables globales de WebGL/Gráficos */
        let gl;
        let programaID;
        let canvas; 

        /* Variables Uniformes */
        let uMatrizProyeccion;
        let uMatrizVista;
        let uMatrizModelo;
        let uUnidadDeTextura;
        
        /* Variables de Texturas */
        let codigoDeTexturaTablero;
        // Se eliminan las variables de textura de fondo
        // ... (resto de texturas de piezas) ...
        let codigodeTexturaReyBlanco, codigodeTexturaReinaBlanca, codigodeTexturaAlfilBlanco, codigodeTexturaCaballoBlanco, codigodeTexturaTorreBlanco, codigodeTexturaPeonBlanco;
        let codigodeTexturaReyNegro, codigodeTexturaReinaNegra, codigodeTexturaAlfilNegro, codigodeTexturaCaballoNegro, codigodeTexturaTorreNegro, codigodeTexturaPeonNegro;

        /* Matrices */
        let MatrizProyeccion = new Array(16);
        let MatrizVista = new Array(16);
        let MatrizModelo = new Array(16);

        /*Variables para el juego*/
        let texturaTablero;
        let peon, rey, reina, alfil, caballo, torre;
        let turno = "Blanco"; 

        /* Datos del Tablero */
        const TAM_CASILLA = 2;
        let primera_eleccion = true;
        let fila_casilla_1, col_casilla_1; /* origen */
        let fila_casilla_2, col_casilla_2; /* destino */
        let pieza;

        // Fila 0 = Arriba (Negras) -> Fila 7 = Abajo (Blancas)
        let tableroMat = [
            ["t","c","a","r","y","a","c","t"], 
            ["p","p","p","p","p","p","p","p"], 
            [" "," "," "," "," "," "," "," "],
            [" "," "," "," "," "," "," "," "],
            [" "," "," "," "," "," "," "," "],
            [" "," "," "," "," "," "," "," "],
            ["P","P","P","P","P","P","P","P"], 
            ["T","C","A","R","Y","A","C","T"]]; 
        
        /* Variables de Animación */
        let animacion = false;
        let x_origen, y_origen;
        let x_destino, y_destino;
        let tiempoInicio;
        const DURACION_ANIMACION = 300; // ms

        /* Ancho y Alto (ventana) */
        const ANCHO = 500;
        const ALTO = 500;

        /***************************************************************************/
        /* Funciones de Matrices y Shaders (Sin cambios)                           */
        /***************************************************************************/
        function compilaEnlazaLosShaders() {
            let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
            gl.compileShader(shaderDeVertice);
            if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(shaderDeVertice)); }
            let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
            gl.compileShader(shaderDeFragmento);
            if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(shaderDeFragmento)); }
            programaID = gl.createProgram();
            gl.attachShader(programaID, shaderDeVertice); 
            gl.attachShader(programaID, shaderDeFragmento);
            gl.linkProgram(programaID);
            if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(programaID)); }
            gl.useProgram(programaID);
        }
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }
        function traslacion(matriz, tx, ty, tz) {
            let r = new Array(16);
            r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
            r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
            multiplica(matriz, matriz, r);
        }
        function multiplica(c, a, b) {
            let r = new Array(16);
            let i, j, k;
            for (i = 0; i < 4; i++){
                for (j = 0; j < 4; j++){
                    let s = 0;
                    for (k = 0; k < 4; k++) s = s + a[i + k * 4] * b[k + j * 4];
                        r[i + j * 4] = s;
                    }
                }
            for (i = 0; i < 16; i++) c[i] = r[i];
        }
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2/(der - izq); r[4] = 0; r[ 8] = 0; r[12] = -(der + izq)/(der - izq);
            r[1] = 0; r[5] = 2/(arr - abj); r[ 9] = 0; r[13] = -(arr + abj)/(arr - abj);
            r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /***************************************************************************/
        /* Lógica de Ajedrez y Animación (Sin cambios, solo la validación de jugadas) */
        /***************************************************************************/
        function getColor(pieza) {
            if (pieza === " ") return null;
            return pieza === pieza.toUpperCase() ? "Blanco" : "Negro";
        }
        function trayectoriaLibre(f1, c1, f2, c2) {
            let df = f2 - f1;
            let dc = c2 - c1;
            let pasoF = Math.sign(df);
            let pasoC = Math.sign(dc);
            let f = f1 + pasoF;
            let c = c1 + pasoC;
            while (f !== f2 || c !== c2) {
                if (tableroMat[f][c] !== " ") {
                    return false; 
                }
                f += pasoF;
                c += pasoC;
            }
            return true; 
        }
        function esMovimientoValido(pieza, f1, c1, f2, c2) {
            let df = Math.abs(f2 - f1); 
            let dc = Math.abs(c2 - c1); 
            let piezaDestino = tableroMat[f2][c2]; 
            let colorOrigen = getColor(pieza); 

            switch (pieza.toUpperCase()) {
                case "P": 
                    let dir = (colorOrigen === "Blanco") ? -1 : 1; 

                    if ((f2 - f1) * dir < 0) return false; 

                    if (dc === 0) {
                        if (piezaDestino !== " ") return false; 
                        
                        if (df === 1) return true;
                        
                        let filaInicial = (colorOrigen === "Blanco") ? 6 : 1;
                        if (df === 2 && f1 === filaInicial && trayectoriaLibre(f1, c1, f2, c2)) return true;
                        
                    } 
                    else if (df === 1 && dc === 1) {
                        return piezaDestino !== " "; 
                    }
                    return false;

                case "C": 
                    return (df === 2 && dc === 1) || (df === 1 && dc === 2); 

                case "A": 
                    if (df === dc) {
                        return trayectoriaLibre(f1, c1, f2, c2);
                    }
                    return false;

                case "T": 
                    if ((df > 0 && dc === 0) || (df === 0 && dc > 0)) {
                        return trayectoriaLibre(f1, c1, f2, c2);
                    }
                    return false;

                case "Y": 
                    return (df <= 1 && dc <= 1);
                    
                case "R": 
                    if (df === dc || df === 0 || dc === 0) {
                        return trayectoriaLibre(f1, c1, f2, c2);
                    }
                    return false;
                    
                default:
                    return false;
            }
        }
        function animaFin() {
            tableroMat[fila_casilla_1][col_casilla_1] = " ";
            tableroMat[fila_casilla_2][col_casilla_2] = pieza;
            animacion = false;
            turno = (turno === "Blanco") ? "Negro" : "Blanco";
            document.getElementById("turno_display").innerText = "Turno: " + turno;
            dibuja();
        }
        function anima() {
            let tiempoActual = Date.now();
            let tiempoTranscurrido = tiempoActual - tiempoInicio;
            let t = tiempoTranscurrido / DURACION_ANIMACION; 
            if (t >= 1) {
                t = 1;
                dibuja(t); 
                animaFin();
                return;
            }
            dibuja(t);
            requestAnimationFrame(anima);
        }
        function mouseDown(event) {
            if (!canvas || animacion) return; 
            let posx = new Number();
            let posy = new Number();

            if (event.x != undefined && event.y != undefined) {
                posx = event.x - canvas.offsetLeft;
                posy = event.y - canvas.offsetTop;
            } else {
                posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft - canvas.offsetLeft;
                posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop - canvas.offsetTop;
            }

            posx = ((posx / ANCHO) * 16);
            posy = ((1- posy / ALTO) * 16); 

            if (primera_eleccion) {
                fila_casilla_1 = Math.trunc(posy / TAM_CASILLA);
                col_casilla_1  = Math.trunc(posx / TAM_CASILLA);
                let piezaElegida = tableroMat[fila_casilla_1][col_casilla_1];
                if (piezaElegida === " ") {
                    return; 
                }
                let colorPieza = getColor(piezaElegida);
                if (colorPieza !== turno) {
                    alert("No es tu turno. Juegan las " + turno + ".");
                    return;
                }
                pieza = piezaElegida;
                primera_eleccion = false;
            } else {
                fila_casilla_2 = Math.trunc(posy / TAM_CASILLA);
                col_casilla_2 = Math.trunc(posx / TAM_CASILLA);

                let piezaDestino = tableroMat[fila_casilla_2][col_casilla_2];
                let colorPiezaMovida = getColor(pieza);
                let colorPiezaDestino = getColor(piezaDestino);

                if (fila_casilla_1 === fila_casilla_2 && col_casilla_1 === col_casilla_2) {
                     primera_eleccion = true;
                     dibuja();
                     return;
                }
                
                if (piezaDestino !== " " && colorPiezaDestino === colorPiezaMovida) {
                     alert("Movimiento inválido: no puedes capturar una pieza de tu propio color.");
                     primera_eleccion = true;
                     dibuja();
                     return;
                }
                
                if (!esMovimientoValido(pieza, fila_casilla_1, col_casilla_1, fila_casilla_2, col_casilla_2)) {
                    alert("Movimiento inválido para esa pieza según las reglas del ajedrez.");
                    primera_eleccion = true;
                    dibuja();
                    return;
                }

                x_origen = col_casilla_1 * TAM_CASILLA;
                y_origen = fila_casilla_1 * TAM_CASILLA;
                x_destino = col_casilla_2 * TAM_CASILLA;
                y_destino = fila_casilla_2 * TAM_CASILLA;
                
                animacion = true;
                tiempoInicio = Date.now();
                
                requestAnimationFrame(anima);
                primera_eleccion = true;
            }
        }

        /***************************************************************************/
        /* Geometría y Dibujo (Sin cambios)                                        */
        /***************************************************************************/
        class PiezaBase {
          constructor(gl) {
            let vertices = [
                0.0, 0.0, 
                2.0, 0.0, 
                2.0, 2.0, 
                0.0, 2.0, 
            ];
            
            let coord_textura = [
                0.0, 0.0, 
                1.0, 0.0, 
                1.0, 1.0, 
                0.0, 1.0, 
            ];
            
            this.vao = gl.createVertexArray();
            
            gl.bindVertexArray(this.vao);
            
            let codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            let codigoCoordenadasDeTextura = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoCoordenadasDeTextura);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coord_textura), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
          }
          dibuja(gl, codigoDeTextura) {
            gl.activeTexture(gl.TEXTURE0); 
            gl.bindTexture(gl.TEXTURE_2D, codigoDeTextura); 
            gl.uniform1i(uUnidadDeTextura, 0);
            gl.bindVertexArray(this.vao);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4); 
            gl.bindVertexArray(null);
          }
        }
        class Peon extends PiezaBase { constructor(gl) { super(gl); } dibuja(gl, codigoDeTextura) { super.dibuja(gl, codigoDeTextura); } }
        class Rey extends PiezaBase { constructor(gl) { super(gl); } dibuja(gl, codigoDeTextura) { super.dibuja(gl, codigoDeTextura); } }
        class Reina extends PiezaBase { constructor(gl) { super(gl); } dibuja(gl, codigoDeTextura) { super.dibuja(gl, codigoDeTextura); } }
        class Alfil extends PiezaBase { constructor(gl) { super(gl); } dibuja(gl, codigoDeTextura) { super.dibuja(gl, codigoDeTextura); } }
        class Caballo extends PiezaBase { constructor(gl) { super(gl); } dibuja(gl, codigoDeTextura) { super.dibuja(gl, codigoDeTextura); } }
        class Torre extends PiezaBase { constructor(gl) { super(gl); } dibuja(gl, codigoDeTextura) { super.dibuja(gl, codigoDeTextura); } }
        
        class Rectangulo { 
            constructor(gl) {
                let vertices = [
                    0, 0, 
                    16, 0, 
                    16, 16, 
                    0, 16, 
                ];

                let coord_textura = [
                    0, 0, 
                    4, 0, 
                    4, 4, 
                    0, 4, 
                ];

                this.rectanguloVAO = gl.createVertexArray();
                gl.bindVertexArray(this.rectanguloVAO);
                let codigoVertices = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                let codigoCoordenadasDeTextura = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, codigoCoordenadasDeTextura);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coord_textura), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);
                gl.bindVertexArray(null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            }
            muestra(gl) {
                gl.bindVertexArray(this.rectanguloVAO);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
                gl.bindVertexArray(null);
            }
        }

        function leeLaTextura(gl, ID_del_archivo, codigoDeTextura) {
            gl.bindTexture(gl.TEXTURE_2D, codigoDeTextura);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            let imagen = document.getElementById(ID_del_archivo);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imagen);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            if (ID_del_archivo !== "imagenTablero") {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            }
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
        
        let _MatrizModelo = new Array(16); 
        function dibuja(t_animacion) {
            gl.clear(gl.COLOR_BUFFER_BIT); // Borra el WebGL con color transparente (0,0,0,0)

            // 1. DIBUJAR EL TABLERO
            identidad(MatrizModelo);
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
            gl.bindTexture(gl.TEXTURE_2D, codigoDeTexturaTablero);
            texturaTablero.muestra(gl); 

            // 2. DIBUJAR LAS PIEZAS FIJAS
            for (let f = 0; f < 8; f++) { 
                for (let c = 0; c < 8; c++) { 
                    let piezaChar = tableroMat[f][c];
                    
                    if (animacion && f === fila_casilla_1 && c === col_casilla_1) {
                         continue;
                    }
                    
                    if (piezaChar !== " ") {
                        let piezaObj;
                        let codigoTextura;

                        switch (piezaChar) {
                            case "P": piezaObj = peon; codigoTextura = codigodeTexturaPeonBlanco; break;
                            case "T": piezaObj = torre;    codigoTextura = codigodeTexturaTorreBlanco; break;
                            case "C": piezaObj = caballo; codigoTextura = codigodeTexturaCaballoBlanco; break;
                            case "A": piezaObj = alfil; codigoTextura = codigodeTexturaAlfilBlanco; break;
                            case "R": piezaObj = reina; codigoTextura = codigodeTexturaReinaBlanca; break;
                            case "Y": piezaObj = rey; codigoTextura = codigodeTexturaReyBlanco; break;
                            case "p": piezaObj = peon; codigoTextura = codigodeTexturaPeonNegro; break;
                            case "t": piezaObj = torre; codigoTextura = codigodeTexturaTorreNegro; break;
                            case "c": piezaObj = caballo; codigoTextura = codigodeTexturaCaballoNegro; break;
                            case "a": piezaObj = alfil; codigoTextura = codigodeTexturaAlfilNegro; break;
                            case "r": piezaObj = reina; codigoTextura = codigodeTexturaReinaNegra; break;
                            case "y": piezaObj = rey; codigoTextura = codigodeTexturaReyNegro; break;
                        }

                        if (piezaObj) {
                            identidad(MatrizModelo);
                            traslacion(MatrizModelo, c * TAM_CASILLA, f * TAM_CASILLA, 0.0); 
                            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
                            piezaObj.dibuja(gl, codigoTextura);
                        }
                    }
                }
            }
            
            // 3. DIBUJAR LA PIEZA EN MOVIMIENTO
            if (animacion && t_animacion !== undefined) {
                let x_interpolado = x_origen * (1 - t_animacion) + x_destino * t_animacion;
                let y_interpolado = y_origen * (1 - t_animacion) + y_destino * t_animacion;

                let piezaObj;
                let codigoTextura;
                switch (pieza.toUpperCase()) {
                    case "P": piezaObj = peon; 
                        codigoTextura = (pieza === pieza.toUpperCase()) ? codigodeTexturaPeonBlanco : codigodeTexturaPeonNegro; 
                        break;
                    case "T": piezaObj = torre; 
                        codigoTextura = (pieza === pieza.toUpperCase()) ? codigodeTexturaTorreBlanco : codigodeTexturaTorreNegro; 
                        break;
                    case "C": piezaObj = caballo; 
                        codigoTextura = (pieza === pieza.toUpperCase()) ? codigodeTexturaCaballoBlanco : codigodeTexturaCaballoNegro; 
                        break;
                    case "A": piezaObj = alfil; 
                        codigoTextura = (pieza === pieza.toUpperCase()) ? codigodeTexturaAlfilBlanco : codigodeTexturaAlfilNegro; 
                        break;
                    case "R": piezaObj = reina; 
                        codigoTextura = (pieza === pieza.toUpperCase()) ? codigodeTexturaReinaBlanca : codigodeTexturaReinaNegra; 
                        break;
                    case "Y": piezaObj = rey; 
                        codigoTextura = (pieza === pieza.toUpperCase()) ? codigodeTexturaReyBlanco : codigodeTexturaReyNegro; 
                        break;
                }

                if (piezaObj) {
                    identidad(MatrizModelo);
                    traslacion(MatrizModelo, x_interpolado, y_interpolado, 0.0);
                    gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
                    piezaObj.dibuja(gl, codigoTextura);
                }
            }
        }

        function main() {
            canvas = document.getElementById("webglcanvas");

            gl = canvas.getContext("webgl2");
            if (!gl) {
                document.write("WebGL 2.0 no está disponible en tu navegador");
                return;
            }

            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            canvas.addEventListener("mousedown", mouseDown, false);

            compilaEnlazaLosShaders();

            // Carga de Texturas (Se omite la carga de textura de fondo en WebGL)
            texturaTablero = new Rectangulo(gl); 
            codigoDeTexturaTablero = gl.createTexture();
            leeLaTextura(gl, "imagenTablero", codigoDeTexturaTablero)

            // Se elimina: codigodeTexturaFondo = gl.createTexture(); y leeLaTextura(gl, "imagenTFondo", codigodeTexturaFondo)

            codigodeTexturaReyBlanco = gl.createTexture(); 
            leeLaTextura(gl, "imagenTReyblanco", codigodeTexturaReyBlanco);

            codigodeTexturaReyNegro = gl.createTexture(); 
            leeLaTextura(gl, "imagenTReyNegro", codigodeTexturaReyNegro);
            
            // ... (el resto de la carga de texturas de las piezas sigue igual) ...
            codigodeTexturaReinaBlanca = gl.createTexture(); 
            leeLaTextura(gl, "imagenTReinaBlanca", codigodeTexturaReinaBlanca);

            codigodeTexturaReinaNegra = gl.createTexture(); 
            leeLaTextura(gl, "imagenTReinaNegro", codigodeTexturaReinaNegra);

            codigodeTexturaAlfilBlanco = gl.createTexture(); 
            leeLaTextura(gl, "imagenTAlfilBlanco", codigodeTexturaAlfilBlanco);

            codigodeTexturaAlfilNegro = gl.createTexture(); 
            leeLaTextura(gl, "imagenTAlfilNegro", codigodeTexturaAlfilNegro);

            codigodeTexturaCaballoBlanco = gl.createTexture(); 
            leeLaTextura(gl, "imagenTCaballoBlanco", codigodeTexturaCaballoBlanco);

            codigodeTexturaCaballoNegro = gl.createTexture(); 
            leeLaTextura(gl, "imagenTCaballoNegro", codigodeTexturaCaballoNegro);

            codigodeTexturaTorreBlanco = gl.createTexture(); 
            leeLaTextura(gl, "imagenTTorreBlanco", codigodeTexturaTorreBlanco);

            codigodeTexturaTorreNegro = gl.createTexture(); 
            leeLaTextura(gl, "imagenTTorreNegro", codigodeTexturaTorreNegro);

            codigodeTexturaPeonBlanco = gl.createTexture(); 
            leeLaTextura(gl, "imagenTPeonBlanco", codigodeTexturaPeonBlanco);

            codigodeTexturaPeonNegro = gl.createTexture(); 
            leeLaTextura(gl, "imagenTPeonNegro", codigodeTexturaPeonNegro);


            // Instanciación de objetos de pieza
            peon = new Peon(gl); 
            rey = new Rey(gl); 
            reina = new Reina(gl); 
            alfil = new Alfil(gl); 
            caballo = new Caballo(gl); 
            torre = new Torre(gl);

            gl.useProgram(programaID);

            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
            uUnidadDeTextura = gl.getUniformLocation(programaID, "uUnidadDeTextura"); 

            ortho(MatrizProyeccion, 0, 16, 0, 16, -5, 5);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

            identidad(MatrizVista);
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
            
            // CLAVE: Activar mezcla y establecer el color de borrado (clearColor) con alfa 0 (transparente)
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.clearColor(0.0, 0.0, 0.0, 0.0); 

            document.getElementById("turno_display").innerText = "Turno: " + turno;
            
            dibuja();
        }
        window.onload = main;
    </script>
</body>
</html>
